«REM»
	  Copyright (c) 2009 Ordina and committers to Mod4j
	  All rights reserved. This program and the accompanying materials
	  are made available under the terms of the Eclipse Public License v1.0
	  which accompanies this distribution, and is available at
	  http://www.eclipse.org/legal/epl-v10.html
	 
	  Contributors:
	      Ordina - initial implementation
«ENDREM»
«IMPORT DataContractDsl»

«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dsl::datacontract::generator::xtend::Dto»

«DEFINE createTranslator FOR Dto»
    «REM»No generation for this super type«ENDREM»
«ENDDEFINE»

«DEFINE createTranslator FOR BusinessClassDto»
        /**
         * DO NOT MODIFY THIS FILE, CHANGES WILL BE AUTOMATICALLY OVERWRITTEN 
         *
         * Generated by Mod4j DataContract DSL in Translators.xpt at: «timestamp()»
         */
         package «getTranslatorsPackage()»;
         
         import java.util.HashMap;
         import java.util.Map;
         import org.mod4j.runtime.exception.TranslatorException;
         import «getDomainRootPackage()».«javaClassName(base.name)»;
         import «getDomainRootPackage()».«javaClassName(base.name)»Example;
         import «getDtoPackage()».«javaClassName(name)»;
         «FOREACH properties.typeSelect(DtoEnumerationProperty) AS enumDto -»
             import «getDtoPackage()».«javaClassName(enumDto.type.name)»;
         «ENDFOREACH»
         «FOREACH properties.typeSelect(DtoAssociationRoleProperty) AS assRef -» 
             import «getDomainRootPackage()».«EXPAND getBaseDtoBaseName FOR assRef.dtoType -»;
         «ENDFOREACH»  
         
        /**
         * Translator for translating «javaClassName(base.name)» domain objects from- and to «javaClassName(name)» data transfer objects. 
         *
         * @author generated by Mod4j
         */
         public class «javaTranslatorName(javaClassName(name))» {
         
             /**
           	  * Thread-local register for translated «javaClassName(base.name)» objects
	          */
		      private static ThreadLocal<Map<«javaClassName(base.name)», «javaClassName(name)»>> translatedHolder = new ThreadLocal<Map<«javaClassName(base.name)», «javaClassName(name)»>>() {
		          public Map<«javaClassName(base.name)», «javaClassName(name)»> initialValue() {
		              return new HashMap<«javaClassName(base.name)», «javaClassName(name)»>();
		          }
		      };
		      private Map<«javaClassName(base.name)», «javaClassName(name)»> getTranslated() {
		          return translatedHolder.get();
		      }

              «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                  «IF dataProperty.metaType == DtoEnumerationProperty -»
                      private «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator «dataProperty.name»Translator = new «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator();
                  «ENDIF»        
              «ENDFOREACH»
                                     
             /**
              * Translates a «javaClassName(name)» dto object into a «javaClassName(base.name)» domain object. All properties in the dto will be mapped to the 
              * corresponding property in the <code>target</code> domain object. Association references in the dto 
              * will not be translated into the <code>target</code> domain object.
              * If the given <code>target</code> parameter is null, a«IF this.creatable» new domain object will be created and returned«ELSE»TranslatorException is thrown«ENDIF».
              *
              * @param source The {@link «javaClassName(name)»} object to translate.
              * @param target The {@link «javaClassName(base.name)»} object translated from source.
              *
              * @return {@link «javaClassName(base.name)»}, the resulting domain object.
              * @throws TranslatorException
              */
              public «javaClassName(base.name)» fromDto(final «javaClassName(name)» source, «javaClassName(base.name)» target) throws TranslatorException {
                 
                  if (source == null ) {
                      throw new TranslatorException("Argument source is null! Translation of a dto can not be based on a null dto.");
                  }
                  
                  «FOREACH properties.select(e|e.mandatoryForCreation) AS nonNullableProp-»
                      if (source.«getterPrefix(nonNullableProp)»«javaClassName(nonNullableProp.name)»() == null) throw new TranslatorException("Can not translate dto to «javaClassName(base.name)» when non-nullable attribute «nonNullableProp.name» is null.");
                  «ENDFOREACH»
                                    
                  «IF this.creatable -»
                      if (target == null) {
                          if (source.getId() != null) {
                              throw new TranslatorException("Can not translate a dto with existng id to a new domain object.");
                          }
                          target = new «javaClassName(base.name) -»(«EXPAND Constructors::addConstructorArgumentsList -»);
                      }
                  «ELSE -»
                      if (target == null ) {
                          throw new TranslatorException("Argument target is null! Translation of this source dto must be based on a existing target domain object.");
                      }
                      if ((source.getId() == null) || (source.getId().equals(target.getId()) == false)) {
                          throw new TranslatorException("Can not translate a dto to a domain object when the id of the dto differs from the id of the domain object.");
                      }
                  «ENDIF» 
                  target.activateValidation(false);                 
                  
                  «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                      «IF dataProperty.writable -»
                          «IF !dataProperty.nullable && !dataProperty.mandatoryForCreation»if (source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»() != null) {«ENDIF-»
                              «IF dataProperty.metaType == DtoEnumerationProperty -»
                                  target.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.fromDto(source.get«javaClassName(dataProperty.name)»()));
                              «ELSE -»
                                      target.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                              «ENDIF -»
                          «IF !dataProperty.nullable && !dataProperty.mandatoryForCreation»}«ENDIF»
                      «ENDIF -»
                  «ENDFOREACH»
                  target.activateValidation(true);

                  return target;
              }
             
             /**
              * Translates a «javaClassName(base.name)» domain object into a «javaClassName(name)» dto object. Properties and associations of the domain object
              * will be mapped to the corresponding properties and associations in the dto object.
              * To prevent looping while translating biderectional or circulair associations translated objects will be added to the 'translated' register.    
              *
              * @param source The {@link «javaClassName(base.name)»} object to translate.
              *
              * @return «javaClassName(name)» The {@link «javaClassName(name)»} object translated from source.
              */
              public «javaClassName(name)» toDto(final «javaClassName(base.name)» source) {
              
                  «FOREACH properties.typeSelect(DtoAssociationRoleProperty) AS assRef -» 
                      «EXPAND getBaseDtoName FOR assRef.dtoType»Translator «assRef.name»Translator = new «EXPAND getBaseDtoName FOR assRef.dtoType»Translator();
                  «ENDFOREACH»  
                 
                  if (source == null ) {
                      throw new TranslatorException("Argument source is null! Translation of a domain object can not be based on a null object.");
                  }
                  
                  if (getTranslated().containsKey((source))) {
                      return getTranslated().get(source);
                  }
 
                  «javaClassName(name)» result = new «javaClassName(name)»();
                 
                  result.setId(source.getId());
                  «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                      «IF dataProperty.metaType == DtoEnumerationProperty -»
                          result.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.toDto(source.get«javaClassName(dataProperty.name)»()));
                      «ELSE -»
                          result.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                      «ENDIF -»
                  «ENDFOREACH»
                  getTranslated().put(source, result);
                  «FOREACH properties.typeSelect(DtoAssociationRoleProperty) AS assRef -»
                     «IF assRef.dtoType.metaType == ListDto -» «REM»2Many«ENDREM» 		              
 		                  for («EXPAND getBaseDtoBaseName FOR assRef.dtoType -» element: source.get«assRef.name.toFirstUpper()»()) {
		                      result.addTo«assRef.name.toFirstUpper()»(«assRef.name»Translator.toDto(element));
		                  }
		             «ELSE -» «REM»2One«ENDREM»
		                 if( source.get«assRef.name.toFirstUpper()»() != null ) {
		                     result.set«assRef.name.toFirstUpper()»(«assRef.name»Translator.toDto(source.get«assRef.name.toFirstUpper()»()));
		                 }
		             «ENDIF -»
		          «ENDFOREACH»
		          getTranslated().remove(source);

                  return result;
              }
              
              «EXPAND exampleFromDto FOR this»
          }
«ENDDEFINE»

«DEFINE exampleFromDto FOR BusinessClassDto»
«LET this.base.name.javaDomainExampleClass() AS ExampleClass»
«LET this.base.name.javaDomainClass() AS Class»

 /**
  * Translates a «javaClassName(name)» dto object into a «ExampleClass» Example domain object. 
  * All properties in the dto will be mapped to the corresponding property in the <code>target</code> domain object. 
  * Association references in the dto will not be translated into the <code>target</code> domain object.
  *
  * @param source The {@link «javaClassName(name)»} object to translate.
  *
  * @return {@link «ExampleClass»}, the resulting businessclass object.
  */
  public «ExampleClass» exampleFromDto(final «javaClassName(name)» source) throws TranslatorException {
  	  «ExampleClass» result = new «ExampleClass»();
     
      if (source == null ) {
          throw new TranslatorException("Argument source is null! Translation of a dto can not be based on a null dto.");
      }

      «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
          «IF dataProperty.metaType == DtoEnumerationProperty -»
              if( source.get«javaClassName(dataProperty.name)»() != null ){
                  result.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.fromDto(source.get«javaClassName(dataProperty.name)»()));
              }
          «ELSE -»
              if( source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»() != null ){
                  result.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
              }
          «ENDIF -»
      «ENDFOREACH»
      return result;
  }
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR ListDto -»
    «javaClassName(baseDto.name) -»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR BusinessClassDto -»
    «javaClassName(name) -»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR BusinessClassDto -»
    «javaClassName(base.name) -»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR ListDto -»
    «EXPAND getBaseDtoBaseName FOR baseDto -»
«ENDDEFINE»