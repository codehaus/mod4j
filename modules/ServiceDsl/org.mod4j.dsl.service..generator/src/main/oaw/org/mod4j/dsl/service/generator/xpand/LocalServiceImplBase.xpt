«IMPORT ServiceDsl»
«IMPORT crossx»

«EXTENSION org::mod4j::dsl::service::mm::xtend::ServiceMethod»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::FileTracker»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx» 

«DEFINE LocalServiceImplBase FOR ServiceModel»
	«FILE generate(javaPathFileName(javaLocalServiceBaseClassPath(name)))»
    /**
     * Generated by Mod4j Service DSL: LocalServiceImplBase::LocalServiceImplBase at: «timestamp()»
     * from model «this.name»
     */
	package «getServiceRootPackage()»;

	import java.util.List;

	import «javaDomainServiceInterface(name)»;
	«FOREACH this.dtoReferences AS dto -»
	import «getDtoPackage()».«javaClassName(dto.name)»;
	«ENDFOREACH»

	«FOREACH this.dtoReferences.select(dto|dto.businessClass() != "void") AS dto -»
	import «javaMapperClassPath(dto.businessClass())»;
	import «javaDomainClassPath(dto.businessClass())»;
	«ENDFOREACH»
	
	/**
	 * @author Generated by Mod4j
	 */
	abstract public class «javaLocalServiceBaseClass(name)» implements  «javaLocalServiceInterface(name)» {

    private «javaDomainServiceInterface(name)» the«javaDomainServiceInterface(name)»;
    
	«FOREACH this.dtoReferences.select(dto|dto.businessClass() != "void") AS dto -»
	private «javaMapperClass(dto.businessClass())» the«javaMapperClass(dto.businessClass())»;
	«ENDFOREACH»


	«FOREACH this.methods.typeSelect(SpecialMethod) AS method»
		«IF method.type == MethodType::Create»
			«EXPAND CreateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::Read»
			«EXPAND ReadMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::Update»
			«EXPAND UpdateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::Delete»
			«EXPAND DeleteMethod FOR method»
		«ENDIF»
	«ENDFOREACH»	

	}
    «ENDFILE»
«ENDDEFINE»

«DEFINE Parameter FOR Parameter»
«JavaType(type)»  «this.name»
«ENDDEFINE»

«DEFINE CreateMethod FOR SpecialMethod»
    /**
     * (@inheritDoc)
     */
    public «JavaType(this.dto)» «this.name»(«JavaType(this.dto)» object){
        «javaDomainClass(dto.businessClass())» result =
              the«javaDomainServiceInterface(model.name)».create«businessClass(this.dto)»( 
                                       the«javaMapperClass(dto.businessClass())».fromDto(object));
        return the«javaMapperClass(dto.businessClass())».toDto(result);
    }
«ENDDEFINE»

«DEFINE ReadMethod FOR SpecialMethod»
    /**
     * Read an existing «this.dto.name».
     * 
     * @param object
     *            the id of the «this.dto.name» to read.
     * @return 
     */
    public «JavaType(this.dto)» «this.name»(Long id) {
        «javaDomainClass(dto.businessClass())» result =
              the«javaDomainServiceInterface(model.name)».read«businessClass(this.dto)»(id);
        return (result == null) ? null : the«javaMapperClass(dto.businessClass())».toDto(result);
    }
«ENDDEFINE»

«DEFINE UpdateMethod FOR SpecialMethod»
   /**
     * Update an existing «this.dto.name».
     * 
     * @param object
     *            the representation of the modified «this.dto.name».
     * @return the «this.dto.name» updated, possibly modified during update.
     */
    public «JavaType(this.dto)» «this.name»(«JavaType(this.dto)» object) {
        «javaDomainClass(dto.businessClass())» tmp = the«javaMapperClass(dto.businessClass())».fromDto(object);
        «javaDomainClass(dto.businessClass())» result = the«javaDomainServiceInterface(model.name)».update«businessClass(this.dto)»(tmp);
        return the«javaMapperClass(dto.businessClass())».toDto(result);
    }
«ENDDEFINE»

«DEFINE DeleteMethod FOR SpecialMethod»
    /**
     * @param id
     *            the id of the «this.dto.name» to delete.
     */
    void «this.name»(Long id){
       the«javaDomainServiceInterface(model.name)».delete«businessClass(this.dto)»(id);
    }
«ENDDEFINE»
