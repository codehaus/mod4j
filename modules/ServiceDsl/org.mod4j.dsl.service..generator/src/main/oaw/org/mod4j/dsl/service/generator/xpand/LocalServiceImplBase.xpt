«IMPORT ServiceDsl»
«IMPORT crossx»

«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dsl::service::mm::xtend::ServiceMethod»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::FileTracker»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx» 

«DEFINE LocalServiceImplBase FOR ServiceModel»
	«FILE generate(getServiceModuleName(), javaPathFileName(javaLocalServiceBaseClassPath(name)))»
    /**
     * Generated by Mod4j Service DSL: LocalServiceImplBase::LocalServiceImplBase at: «timestamp()»
     * from model «this.name»
     */
	package «getServiceRootPackage()»;

	import java.util.List;
	import org.mod4j.runtime.exception.TranslatorException;
	import org.mod4j.runtime.exception.ServiceException;

	import «javaDomainServiceInterfacePath(name)»;

	«FOREACH this.dtoReferences.select(e|e.dtoType() != "ListDto") AS dto -»
	import «getDtoPackage()».«javaClassName(dto.name)»;
	«ENDFOREACH»

	«FOREACH this.dtoReferences.select(dto|dto.businessClass() != "void") AS dto -»
	import «javaTranslatorClassPath(dto.name)»;
	import «javaDomainClassPath(dto.businessClass())»;
	«ENDFOREACH»
	
	/**
	 * @author Generated by Mod4j
	 */
	abstract public class «javaLocalServiceBaseClass(name)» implements  «javaLocalServiceInterface(name)» {

	«EXPAND FieldGetterSetter::field(javaDomainServiceInterface(name)) FOR "the" + javaDomainServiceInterface(name)»    

	«FOREACH this.dtoReferences.select(dto|dto.businessClass() != "void") AS dto -»
	«EXPAND FieldGetterSetter::field(javaTranslatorClass(dto.name)) FOR "the" + javaTranslatorClass(dto.name)»    
	«ENDFOREACH»


	«FOREACH this.methods.typeSelect(SpecialMethod) AS method»
		«IF method.type == MethodType::CREATE»
			«EXPAND CreateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::READ»
			«EXPAND ReadMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::UPDATE»
			«EXPAND UpdateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::DELETE»
			«EXPAND DeleteMethod FOR method»
		«ENDIF»
	«ENDFOREACH»	
«REM»
	«EXPAND  ReadMethod FOREACH this.uniqueMethods(MethodType::READ) »
«ENDREM»
	«EXPAND Associations FOR this»
	}
    «ENDFILE»
«ENDDEFINE»

«DEFINE Parameter FOR Parameter»
«JavaType(type)»  «this.name»
«ENDDEFINE»

«DEFINE CreateMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.dto)» «this.name»(«JavaType(this.dto)» object){
        «javaDomainClass(dto.businessClass())» result = null;
	        result = the«javaDomainServiceInterface(model.name)».create«businessClass(this.dto)»(the«javaTranslatorClass(dto.name)».fromDto(object, null));
        return the«javaTranslatorClass(dto.name)».toDto(result);
    }
«ENDDEFINE»

«DEFINE ReadMethod FOR SpecialMethod»
    /**
     * Read an existing «this.dto.name».
     * 
     * @param object
     *            the id of the «this.dto.name» to read.
     * @return 
     */
    public «JavaType(this.dto)» «this.name»(Long id) {
        «javaDomainClass(dto.businessClass())» result =
              the«javaDomainServiceInterface(model.name)».read«businessClass(this.dto)»(id);
        return (result == null) ? null : the«javaTranslatorClass(dto.name)».toDto(result);
    }
«ENDDEFINE»

«DEFINE UpdateMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.dto)» «this.name»(«JavaType(this.dto)» object) {
    
        «javaDomainClass(dto.businessClass())» result = null;
        result = the«javaDomainServiceInterface(model.name)».read«businessClass(this.dto)»(object.getId());
        if (result == null) throw new ServiceException("Can not update «businessClass(this.dto)» for «JavaType(this.dto)», because the corresponding «businessClass(this.dto)» does not exist.");
        
        result = the«javaTranslatorClass(dto.name)».fromDto(object, result);
        result = the«javaDomainServiceInterface(model.name)».update«businessClass(this.dto)»(result);
        
        return the«javaTranslatorClass(dto.name)».toDto(result);
    }
«ENDDEFINE»

«DEFINE DeleteMethod FOR SpecialMethod»
    /**
     * @param object
     *            The «this.dto.name» object to delete.
     */
    public void «this.name»(«JavaType(this.dto)» object){
		
		if (object == null) throw new ServiceException("Could not delete «this.dto.name» based on a null «JavaType(this.dto)»");
		«javaDomainClass(dto.businessClass())» existing = the«javaDomainServiceInterface(model.name)».read«businessClass(this.dto)»(object.getId());
		if (existing == null) {
            throw new ServiceException("Could not delete «this.dto.name» because it does not exist.");
        }
	    the«javaDomainServiceInterface(model.name)».delete«businessClass(this.dto)»(existing);
    }
«ENDDEFINE»

«DEFINE Associations FOR ServiceModel»
    // Association related service method
	«FOREACH this.methods.typeSelect(AssociationMethod) AS method»
	«LET getAssociation(method) AS assoc» 
    «LET getPropertyValue(assoc, "Multiplicity") AS mult»
    «LET ((mult == "0..1") || (mult == "1") ? "set" : "addTo") + method.rolename.toFirstUpper() AS genName»
	
		«REM»The addTo method«ENDREM»
		«IF method.type == MethodType::ADDTO»
		public void «genName»(«method.part.name» part, «method.main.name» whole) {
			if( (part == null) || (whole == null) ) { return; }
			«method.part.businessClass()» partBusinessObject = the«javaDomainServiceInterface(this.name)».read«method.part.businessClass()»(part.getId());
			if(partBusinessObject == null) { return ; }
	
			«method.main.businessClass()» mainBusinessObject = the«javaDomainServiceInterface(this.name)».read«method.main.businessClass()»(whole.getId());
			if(mainBusinessObject  == null) { return ; }
	
			the«javaDomainServiceInterface(this.name)».«genName»(partBusinessObject, mainBusinessObject);
			return ;
		}
		«ENDIF»
	
		«REM»And the removeFrom method«ENDREM»
		«IF method.type == MethodType::REMOVEFROM»
		public void removeFrom«method.rolename.toFirstUpper()»(«method.part.name» part, «method.main.name» whole) {
			if( (part == null) || (whole == null) ) { return; }
			«method.part.businessClass()» partObject = the«javaDomainServiceInterface(this.name)».read«method.part.businessClass()»(part.getId());
			if(partObject == null) { return ; }
			«method.main.businessClass()» wholeObject = the«javaDomainServiceInterface(this.name)».read«method.main.businessClass()»(whole.getId());
			if(wholeObject == null) { return ; }
			
			the«javaDomainServiceInterface(this.name)».removeFrom«method.rolename.toFirstUpper()»(partObject, wholeObject);
		}
		«ENDIF»
	«ENDLET»
	«ENDLET»
	«ENDLET»
	«ENDFOREACH»
«ENDDEFINE»

