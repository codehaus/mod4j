«REM»
	  Copyright (c) 2009 Ordina and committers to Mod4j
	  All rights reserved. This program and the accompanying materials
	  are made available under the terms of the Eclipse Public License v1.0
	  which accompanies this distribution, and is available at
	  http://www.eclipse.org/legal/epl-v10.html
	 
	  Contributors:
	      Ordina - initial implementation
«ENDREM»
«IMPORT ServiceDsl»
«IMPORT crossx»
«IMPORT org::mod4j::dslcommon::xpand::java»

«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dsl::service::mm::xtend::ServiceMethod»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx» 

«DEFINE LocalServiceImplBase FOR ServiceModel»
    «EXPAND JavaComments::regenerationWarningHeader ("Mod4j ServiceDsl generator: LocalServiceImplBase.xpt") FOR this»

	package «getServiceRootPackage()»;

	import java.util.List;
	import java.util.ArrayList;
	
	import org.mod4j.runtime.exception.TranslatorException;
	import org.mod4j.runtime.exception.ServiceException;

	import «javaDomainServiceInterfacePath(name)»;

	«FOREACH this.dtoReferences.select(e|e.dtoType() == "ListDto") AS dto -»
	    «LET lookupSymbol(dto.modelname, dto.name, "Dto").getPropertyValue("baseDto") AS baseDtoName»
	        import «getServiceRootPackage()».dto.«baseDtoName»;
	        import «javaTranslatorClassPath(baseDtoName)»;
	    «ENDLET»
	«ENDFOREACH»


	«FOREACH this.dtoReferences.select(e|e.dtoType() != "ListDto") AS dto -»
	import «getDtoPackage()».«javaClassName(dto.name)»;
	«ENDFOREACH»

	«FOREACH this.dtoReferences.select(dto|dto.businessClass() != "void") AS dto -»
	import «javaTranslatorClassPath(dto.name)»;
	import «javaDomainClassPath(dto.businessClass())»;
	import «javaDomainExampleClassPath(dto.businessClass())»;
	«ENDFOREACH»
	
	/**
	 * @author Generated by Mod4j
	 */
	abstract public class «javaLocalServiceBaseClass(name)» implements  «javaLocalServiceInterface(name)» {

	«EXPAND FieldGetterSetter::field(javaDomainServiceInterface(name)) FOR javaDomainServiceInterface(name).toFirstLower()»    

	«FOREACH this.getAllBusinessClassDtoSymbols() AS classDtoSymbol»
	«EXPAND FieldGetterSetter::field(javaTranslatorClass(classDtoSymbol.name)) FOR javaTranslatorClass(classDtoSymbol.name).toFirstLower()»    
	«ENDFOREACH»

	«FOREACH this.methods.typeSelect(SpecialMethod) AS method»
		«IF method.type == MethodType::CREATE»
			«EXPAND CreateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::READ»
			«EXPAND ReadMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::UPDATE»
			«EXPAND UpdateMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::DELETE»
			«EXPAND DeleteMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::LISTALL»
			«EXPAND ListallMethod FOR method»
		«ENDIF»
		«IF method.type == MethodType::FIND»
			«EXPAND FindMethod FOR method»
		«ENDIF»
	«ENDFOREACH»
	
	«EXPAND CountMethod FOREACH this.uniqueMethods(MethodType::LISTALL) »
		
	«EXPAND Associations FOR this»
	}
«ENDDEFINE»

«DEFINE Parameter FOR Parameter»
«JavaType(type)»  «this.name»
«ENDDEFINE»

«DEFINE CreateMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.dto)» «this.name»(«JavaType(this.dto)» object){
        «javaDomainClass(dto.businessClass())» result = null;
	        result = «javaDomainServiceInterface(model.name).toFirstLower()».create«businessClass(this.dto)»(«javaTranslatorClass(dto.name).toFirstLower()».fromDto(object));
        return «javaTranslatorClass(dto.name).toFirstLower()».toDto(result);
    }
«ENDDEFINE»

«DEFINE ReadMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.dto)» «this.name»(Long id) {
        «javaDomainClass(dto.businessClass())» result =
              «javaDomainServiceInterface(model.name).toFirstLower()».read«businessClass(this.dto)»(id);
        return (result == null) ? null : «javaTranslatorClass(dto.name).toFirstLower()».toDto(result);
    }
«ENDDEFINE»

«DEFINE UpdateMethod FOR SpecialMethod»
«LET this.model.methods.typeSelect(SpecialMethod).select(m|m.type == MethodType::READ && (m.dto == this.dto)).first() AS readmethod»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.dto)» «this.name»(«JavaType(this.dto)» object) {
    
        «javaDomainClass(dto.businessClass())» result = null;
        try {
            result = «javaDomainServiceInterface(model.name).toFirstLower()».read«businessClass(this.dto)»(object.getId());
        } catch (IllegalArgumentException e) {
            throw new ServiceException("Can not update «businessClass(this.dto)» for «JavaType(this.dto)»", e);
        }
        if (result == null) throw new ServiceException("Can not update «businessClass(this.dto)» for «JavaType(this.dto)», because the corresponding «businessClass(this.dto)» does not exist.");
        
        result = «javaTranslatorClass(dto.name).toFirstLower()».fromDto(object, result);
        result = «javaDomainServiceInterface(model.name).toFirstLower()».update«businessClass(this.dto)»(result);
        
        return «javaTranslatorClass(dto.name).toFirstLower()».toDto(result);
    }
«ENDLET»
«ENDDEFINE»

«DEFINE DeleteMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public void «this.name»(«JavaType(this.dto)» object){
		
		if (object == null) throw new ServiceException("Could not delete «this.dto.name» based on a null «JavaType(this.dto)»");
		«javaDomainClass(dto.businessClass())» existing = null;
		try {
    		existing = «javaDomainServiceInterface(model.name).toFirstLower()».read«businessClass(this.dto)»(object.getId());
    	} catch (IllegalArgumentException e) {
    	    throw new ServiceException("Could not delete «this.dto.name»", e);
    	}
		if (existing == null) {
            throw new ServiceException("Could not delete «this.dto.name» because it does not exist.");
        }
	    «javaDomainServiceInterface(model.name).toFirstLower()».delete«businessClass(this.dto)»(existing);
    }
«ENDDEFINE»

«DEFINE ListallMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public List<«JavaType(this.dto)»> «this.name»() {
		List<«this.dto.businessClass()»> all = «javaDomainServiceInterface(model.name).toFirstLower()».listAll«this.dto.businessClass()»s();
		List<«JavaType(this.dto)»> result = new ArrayList<«JavaType(this.dto)»>();
		
		for («this.dto.businessClass()» object : all) {
			«JavaType(this.dto)» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
			result.add(item);
		}
		return result;
    }
    
    /**
     * {@inheritDoc}
     */
    public List<«JavaType(this.dto)»> «this.name»(final int firstResult, final int maxResults) {
        List<«this.dto.businessClass()»> range = «javaDomainServiceInterface(model.name).toFirstLower()».list«this.dto.businessClass()»s(firstResult, maxResults);
        List<«JavaType(this.dto)»> result = new ArrayList<«JavaType(this.dto)»>();
        
        for («this.dto.businessClass()» object : range) {
            «JavaType(this.dto)» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
            result.add(item);
        }
        return result;
    }
«ENDDEFINE»

«DEFINE CountMethod FOR SpecialMethod»
    /**
     * {@inheritDoc}
     */
    public long count«this.dto.businessClass()»s() {
        return «javaDomainServiceInterface(model.name).toFirstLower()».count«this.dto.businessClass()»s();
    }
«ENDDEFINE»

«DEFINE FindMethod FOR SpecialMethod»
«LET JavaType(this.dto) AS dtoType»
«LET javaDomainClass(this.dto.businessClass()) AS Class»
    /**
     * {@inheritDoc}
     */
	public List<«dtoType»> «this.name»(«dtoType» example) {
		List<«Class»> found = null;
		List<«dtoType»> result = new ArrayList<«dtoType»>();

		«this.dto.businessClass().javaDomainExampleClass()» bexample =
		              «javaTranslatorClass(dto.name).toFirstLower()».exampleFromDto(example);
		found = «javaDomainServiceInterface(model.name).toFirstLower()».find«Class»ByExample(bexample);
		
		for («Class» object : found) {
			«dtoType» item = «javaTranslatorClass(dto.name).toFirstLower()».toDto(object);
			result.add(item);
		}
		return result;

	}
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE Associations FOR ServiceModel»
// Association related service methods
	«FOREACH this.methods.typeSelect(AssociationMethod) AS method»
	«LET getAssociation(method) AS assoc» 
    «LET getPropertyValue(assoc, "Multiplicity") AS mult»
	
		«REM»The addTo or set method «ENDREM»
		«IF method.type == MethodType::ADDTO»
			«IF (mult == "ONE") »
				«EXPAND setMethod FOR method»
			«ELSE»
				«EXPAND addToMethod FOR method»
			«ENDIF»
		«ENDIF»

		«REM»The get method for multiplicity one or many«ENDREM»
		«IF method.type == MethodType::GETFROM»
			«IF (mult == "ONE") »
				«EXPAND getOneMethod FOR method»
			«ELSE»
				«EXPAND getManyMethod FOR method»
			«ENDIF»
		«ENDIF»
	
		«REM»And the removeFrom method«ENDREM»
		«IF method.type == MethodType::REMOVEFROM»
	    /**
	     * {@inheritDoc}
	     */
		public void «method.name»(«method.main.name» whole, «method.part.name» part) {
			if( part == null ) { 
			    throw new ServiceException("removeFrom«method.rolename.toFirstUpper()»: parameter [part] should not be null");
			}
			if( whole == null ) { 
			    throw new ServiceException("removeFrom«method.rolename.toFirstUpper()»: parameter [whole] should not be null");
			}
			«method.part.businessClass()» partObject = «javaDomainServiceInterface(this.name).toFirstLower()».read«method.part.businessClass()»(part.getId());
			if(partObject == null) { 
			    throw new ServiceException("removeFrom«method.rolename.toFirstUpper()»: cannot find business object for parameter [part]");
			}
			«method.main.businessClass()» wholeObject = «javaDomainServiceInterface(this.name).toFirstLower()».read«method.main.businessClass()»(whole.getId());
			if(wholeObject == null) { 
			    throw new ServiceException("removeFrom«method.rolename.toFirstUpper()»: cannot find business object for parameter [whole]");
			}
			
			«javaDomainServiceInterface(this.name).toFirstLower()».removeFrom«method.rolename.toFirstUpper()»(wholeObject, partObject);
		}
		«ENDIF»
	«ENDLET»
	«ENDLET»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE addToMethod FOR AssociationMethod»
    /**
     * {@inheritDoc}
     */
	public void «this.name»(«this.main.name» whole, «this.part.name» part) {
		if( part == null ) { 
		    throw new ServiceException("addTo«this.rolename.toFirstUpper()»: parameter [part] should not be null");
		}
		if( whole == null ) { 
		    throw new ServiceException("addTo«this.rolename.toFirstUpper()»: parameter [whole] should not be null");
		}

		«this.part.businessClass()» partBusinessObject = «javaDomainServiceInterface(this.model.name).toFirstLower()».read«this.part.businessClass()»(part.getId());
		if(partBusinessObject == null) { 
		    throw new ServiceException("addTo«this.rolename.toFirstUpper()»: cannot find business object for parameter [part]");
		}

		«this.main.businessClass()» mainBusinessObject = «javaDomainServiceInterface(this.model.name).toFirstLower()».read«this.main.businessClass()»(whole.getId());
		if(mainBusinessObject  == null) { 
		    throw new ServiceException("addTo«this.rolename.toFirstUpper()»: cannot find business object for parameter [whole]");
		}

		«javaDomainServiceInterface(this.model.name).toFirstLower()».addTo«this.rolename.toFirstUpper()»(mainBusinessObject, partBusinessObject);
		return ;
	}
«ENDDEFINE»

«DEFINE setMethod FOR AssociationMethod»
    /**
     * {@inheritDoc}
     */
	public void «this.name»(«this.main.name» whole, «this.part.name» part) {
			if( whole == null ) { 
			    throw new ServiceException("set«this.rolename.toFirstUpper()»: parameter [whole] should not be null");
			}
		«this.part.businessClass()» partBusinessObject = null;
		if( part != null ) {
	        partBusinessObject = «javaDomainServiceInterface(this.model.name).toFirstLower()».read«this.part.businessClass()»(part.getId());
	    }

		«this.main.businessClass()» mainBusinessObject = «javaDomainServiceInterface(this.model.name).toFirstLower()».read«this.main.businessClass()»(whole.getId());
		if(mainBusinessObject  == null) { 
		    throw new ServiceException("set«this.rolename.toFirstUpper()»: cannot find business object for parameter [whole]");
		}

		«javaDomainServiceInterface(this.model.name).toFirstLower()».set«this.rolename.toFirstUpper()»(mainBusinessObject, partBusinessObject);
		return ;
	}
«ENDDEFINE»

«DEFINE getOneMethod FOR AssociationMethod»
«LET javaDomainServiceInterface(this.model.name).toFirstLower() AS domainService»
    /**
     * {@inheritDoc}
     */
    public «JavaType(this.part)» «this.name»(«this.main.name» source){
		if (source == null) {
			throw new ServiceException(
					"get«this.rolename.toFirstUpper()»: parameter [source] should not be null");
		}
		«this.part.businessClass()» target = null;

		«this.main.businessClass()» sourceBusinessObject = «domainService».read«this.main.businessClass()»(source.getId());
		if (sourceBusinessObject == null) {
			throw new ServiceException(
					"get«this.rolename.toFirstUpper()»: cannot find business object for parameter [source]");
		}
		target = «domainService».get«this.part.businessClass()»(sourceBusinessObject);
		return «javaTranslatorClass(this.part.name).toFirstLower()».toDto(target);
    }
«ENDLET»
«ENDDEFINE»

«DEFINE getManyMethod FOR AssociationMethod»
«LET javaDomainServiceInterface(this.model.name).toFirstLower() AS domainService»
    /**
     * {@inheritDoc}
     */
	public «JavaType(this.part)» «this.name»(«this.main.name» source){
		if (source == null) {
			throw new ServiceException(
					"get«this.rolename.toFirstUpper()»: parameter [source] should not be null");
		}
		«this.main.businessClass()» businessSource = «domainService».read«this.main.businessClass()»(source.getId());
		List<«this.part.dtoBaseBusinessClass()»> parts = «domainService».get«this.rolename.toFirstUpper()»(businessSource);

		List<«this.part.baseDtoSymbol().name»> result = new ArrayList<«this.part.baseDtoSymbol().name»>();

		for («this.part.dtoBaseBusinessClass()» element: parts) {
			«this.part.baseDtoSymbol().name» item = «javaTranslatorClass(this.part.baseDtoSymbol().name).toFirstLower()».toDto(element);
			result.add(item);
		}

		return result;
    }
«ENDLET»    
«ENDDEFINE»
