«REM»
	  Copyright (c) 2009 Ordina and committers to Mod4j
	  All rights reserved. This program and the accompanying materials
	  are made available under the terms of the Eclipse Public License v1.0
	  which accompanies this distribution, and is available at
	  http://www.eclipse.org/legal/epl-v10.html
	 
	  Contributors:
	      Ordina - initial implementation
«ENDREM»
«IMPORT ServiceDsl»
«IMPORT crossx»
«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dsl::service::mm::xtend::ServiceMethod»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::common::xtend::FileTracker»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx» 


«DEFINE BusinessServiceImplBase FOR ServiceModel»
    /**
     * DO NOT MODIFY THIS FILE, CHANGES WILL BE AUTOMATICALLY OVERWRITTEN 
     *
     * Generated by Mod4j Service DSL: BusinessServiceImpl::BusinessServiceImplBase at: «timestamp()»
     * from model «this.name»
     */
	package «getBusinessRootPackage()»;

	import java.util.List;
	import java.util.ArrayList;
«REM»Import the business class  and dao for aech base of each BusinessClassDto. 
     Ensure that doules are removed.
«ENDREM»	
	«FOREACH this.uniqueBusinessClasses() AS cls -»
	    import «javaDomainClassPath(cls)»;  
    	import «javaDomainExampleClassPath(cls )»;
		import «javaDaoInterfacePath(cls)»; 
	«ENDFOREACH»

	/**
	 * @author Generated by Mod4j
	 */
	abstract public class «javaDomainServiceBaseClass(name)» implements «javaDomainServiceBaseInterface(name)» {

	«FOREACH this.uniqueBusinessClasses() AS cls -»
		«EXPAND FieldGetterSetter::field(javaDaoInterface(cls)) FOR javaDaoInterface(cls).toFirstLower()»    
	«ENDFOREACH»


	«EXPAND  CreateMethod  FOREACH this.uniqueMethods(MethodType::CREATE) »
	«EXPAND  ReadMethod    FOREACH this.uniqueMethods(MethodType::READ) »
	«EXPAND  UpdateMethod  FOREACH this.uniqueMethods(MethodType::UPDATE) »
	«EXPAND  DeleteMethod  FOREACH this.uniqueMethods(MethodType::DELETE) »
	«EXPAND  ListallMethod FOREACH this.uniqueMethods(MethodType::LISTALL) »
	«EXPAND  FindMethod    FOREACH this.uniqueMethods(MethodType::FIND) »

    «EXPAND  Associations FOR this»
	}
«ENDDEFINE»

«DEFINE Parameter FOR Parameter»
«businessClass(type)»  «this.name»
«ENDDEFINE»

«DEFINE CreateMethod FOR SpecialMethod»
    /**
     * Create a new «dto.businessClass()».
     * 
     * @param object
     *            the «dto.businessClass()» to create.
     * @return the «dto.businessClass()» created, possibly modified during creation.
     */
    public «javaDomainClass(dto.businessClass())» create«this.dto.businessClass()»(«javaDomainClass(dto.businessClass())» object) {
        return «javaDaoInterface(dto.businessClass()).toFirstLower()».add(object);
    }
«ENDDEFINE»

«DEFINE ReadMethod FOR SpecialMethod»
    /**
     * Read an existing «dto.businessClass()».
     * 
     * @param object
     *            the id of the «dto.businessClass()» to read.
     * @return 
     */
    public «javaDomainClass(dto.businessClass())»  read«this.dto.businessClass()»(Long id){
        return «javaDaoInterface(dto.businessClass()).toFirstLower()».retrieve(id);
    }
«ENDDEFINE»

«DEFINE UpdateMethod FOR SpecialMethod»
   /**
     * Update an existing «dto.businessClass()».
     * 
     * @param object
     *            the representation of the modified «businessClass(this.dto)».
     * @return the «businessClass(this.dto)» updated, possibly modified during update.
     */
    public «javaDomainClass(dto.businessClass())»  update«this.dto.businessClass()»(«javaDomainClass(dto.businessClass())» object) {
        return «javaDaoInterface(dto.businessClass()).toFirstLower()».update(object);
    }
«ENDDEFINE»

«DEFINE DeleteMethod FOR SpecialMethod»
    /**
     * @param id
     *            the id of the «dto.businessClass()» to delete.
     */
    public void delete«this.dto.businessClass()»(«businessClass(this.dto)» object){
        «javaDaoInterface(dto.businessClass()).toFirstLower()
        ».delete(object);
    }
«ENDDEFINE»

«DEFINE ListallMethod FOR SpecialMethod»
    /**
     * List all «dto.businessClass()»s.
     * 
     * @return List<«dto.businessClass()»>
     */
    public List<«javaDomainClass(dto.businessClass())»>  listAll«this.dto.businessClass()»s(){
        return «javaDaoInterface(dto.businessClass()).toFirstLower()».listAll();
    }
«ENDDEFINE»

«DEFINE FindMethod FOR SpecialMethod»
«LET javaDomainClass(dto.businessClass()) AS Class»
    /**
     * Find all «Class» that look like the «dto.name».
     * 
     * @return List<«Class»>
     */
    public List<«Class»> find«Class»ByExample(«javaDomainExampleClass(dto.businessClass())» example) {
        return this.«javaDaoInterface(dto.businessClass()).toFirstLower()».findByExample(example);
    }
«ENDLET»
«ENDDEFINE»


«DEFINE Associations FOR ServiceModel»
	«FOREACH this.methods.typeSelect(AssociationMethod) AS method»
	«LET getAssociation(method) AS assoc» 
	«LET getPropertyValue(assoc, "Multiplicity") AS mult»
	«LET getPropertyValue(assoc, "ordered") AS ordered»
    «LET ((mult == "ONE") ? "set" : "addTo") + method.rolename.toFirstUpper() AS genName»
		«REM»The addTo method«ENDREM»	
		«IF method.type == MethodType::ADDTO»
		public void «genName»(«method.main.businessClass()» whole, «method.part.businessClass()» part) {
			whole.«genName»(part);
			«javaDaoInterface(method.main.businessClass()).toFirstLower()».update(whole);
		}
			«IF ordered == "true" »
			public void «genName»(«method.main.businessClass()» whole, int index, «method.part.businessClass()» part) {
                whole.«genName»(index, part); 
	            «javaDaoInterface(method.main.businessClass()).toFirstLower()».update(whole);
	        }
			«ENDIF»
		«ENDIF»
	
		«REM»The removefrom method«ENDREM»	
		«IF (method.type == MethodType::REMOVEFROM) && (mult == "MANY") »
		public void removeFrom«method.rolename.toFirstUpper()»(«method.main.businessClass()» whole, «method.part.businessClass()» part) {
			whole.removeFrom«method.rolename.toFirstUpper()»(part);
			«javaDaoInterface(method.main.businessClass()).toFirstLower()».update(whole);
			«javaDaoInterface(method.part.businessClass()).toFirstLower()».update(part);
		}
			«IF ordered == "true" »
			public void removeFrom«method.rolename.toFirstUpper()»(«method.main.businessClass()» whole, int index) {
				whole.removeFrom«method.rolename.toFirstUpper()»(index);
				«javaDaoInterface(method.main.businessClass()).toFirstLower()».update(whole);
			}
			«ENDIF»
		«ENDIF»
		
		«IF method.type == MethodType::GETFROM»
			«IF (mult == "ONE")»
			public «method.part.businessClass()» get«method.rolename.toFirstUpper()»(«method.main.businessClass()» source){
			    return source.get«method.rolename.toFirstUpper()»();
			}
			«ELSE»			
			public List<«method.part.dtoBaseBusinessClass()»> get«method.rolename.toFirstUpper()»(«method.main.businessClass()» source){
			    return new ArrayList<«method.part.dtoBaseBusinessClass()»>( source.get«method.rolename.toFirstUpper()»() );
			}
			«ENDIF»
		«ENDIF»
		
	«ENDLET»
	«ENDLET»
	«ENDLET»
	«ENDLET»
	«ENDFOREACH»
«ENDDEFINE»

