<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4/EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY logical-view SYSTEM "images/logical-view.jpg" NDATA JPG>
]>
<book lang="en">
  <bookinfo><title>mod4j Application Architecture</title><author>
      <firstname>Eric</firstname>
      <othername>Jan</othername>
      <surname>Malotaux</surname>
    </author>
    <releaseinfo>&version;</releaseinfo>
    <copyright>
      <year>2009</year>
      <holder>Ordina J-Technologies</holder>
    </copyright>
  </bookinfo>
  <chapter>
    <title>Introduction</title>
    <section>
      <title>Scope</title>
      <para/>
    </section>
    <section>
      <title>References</title>
      <bibliography>
        <biblioentry id="busch96">
          <abbrev>Busch96</abbrev>
          <title>Pattern-Oriented Software Architecture - A System of Patterns</title><authorgroup>
            <author>
              <firstname>Frank</firstname>
              <surname>Buschmann</surname>
            </author>
            <author>
              <surname>Meunier</surname>
              <firstname>Regine</firstname>
            </author>
            <author>
              <surname>Rohnert</surname>
              <firstname>Hans</firstname>
            </author>
            <author>
              <surname>Sommerlad</surname>
              <firstname>Peter</firstname>
            </author>
            <author>
              <surname>Stal</surname>
              <firstname>Michael</firstname>
            </author>
          </authorgroup><publisher>
            <publishername>John Wiley &amp; Sons</publishername>
          </publisher>
          <date>1996</date>
        </biblioentry>
        <biblioentry id="evans03">
          <abbrev>Evans03</abbrev>
          <title>Domain-Driven Design: Tackling Complexity in the Heart of Software</title><author>
            <firstname>Eric</firstname>
            <surname>Evans</surname>
          </author><publisher>
            <publishername>Addison-Wesley</publishername>
          </publisher>
          <date>2003</date>
          <isbn>0-321-12521-5</isbn>
        </biblioentry>
        <biblioentry id="fowler02">
          <abbrev>Fowler02</abbrev>
          <author>
            <firstname>Martin</firstname>
            <surname>Fowler</surname>
          </author><title>Patterns of Enterprise Application Architecture</title><publisher>
            <publishername>Addison-Wesley</publishername>
          </publisher>
          <date>2002</date>
          <isbn>0-321-12742-0</isbn>
        </biblioentry>
        <biblioentry id="spring25"><abbrev>Spring25</abbrev><authorgroup>
            <author><firstname>Rod</firstname><surname>Johnson et al.</surname></author>
          </authorgroup><title>java/j2ee Application Framework</title><subtitle>The Spring Framework
            - Reference Documentation</subtitle><releaseinfo>Version
              2.5</releaseinfo><copyright><year>2004-2007</year></copyright></biblioentry>
      </bibliography>
      <para/>
    </section>
    <section>
      <title>Abbreviations</title>
      <para/>
    </section>
    <section>
      <title>Structure of this document</title>
      <para/>
    </section>
  </chapter>
  <chapter>
    <title>Logical View</title>
    <para>This chapter describes the logical composition of the mod4j Reference Architecture. It
      defines the layers, the component types in each layer and the responsibilities of these
      component types.</para>
    <section>
      <title>Overview</title>
      <para><figure>
          <title>Logical view</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/logical-view.jpg" format="JPG"/>
            </imageobject>
          </mediaobject>
        </figure>The <emphasis>Layers</emphasis> architectural pattern itself is described in
          <biblioref linkend="busch96"/>. The <emphasis>Presentation Layer</emphasis> provides an
        interface to the system to a human user, presenting information and interpreting actions of
        the user. It uses the Service Layer to obtain the information or execute other operations
        that the Service Layer offers. The <emphasis>Service Layer</emphasis> provides access to the
        services of the Business Layer using a particular access protocol, like SOAP, EJB, RMI or
        local method invocation. The <emphasis>Business Layer</emphasis> provides services that
        implement functionality and business logic. The <emphasis>Data Layer</emphasis> provides
        access to persistent data on behalf of the Business Layer. The <emphasis>Domain
          Model</emphasis> consists of Objects that model the part of the world of interest to the
        application. The next paragraphs describes the responsibilities and the structure of the
        layers in more detail.</para>
    </section>
    <section>
      <title>Presentation Layer</title>
      <para>The Presentation Layer contains components that present information to a user and
        interprets his actions by executing functions of the system.Typical responsibilities of the
        Presentation Layer include:</para>
      <itemizedlist>
        <listitem>
          <para>Presenting data to the user. This implies mapping fields on a screen to attibutes of
              <emphasis>Data Transfer Objects</emphasis> received from the Service Layer, formatting
            of data, internationalisation en localisation of data.</para>
        </listitem>
        <listitem>
          <para>Accepting data entered by the user. This implies applying simple validations on the
            data entered and keeping track of this data.</para>
        </listitem>
      </itemizedlist>
      <para>This Presentation Layer should not execute business functionality by itself, but instead
        delegate that responsibility to the Service Layer by calling its operations. Data is
        transferred to and from the Service Layer in the form of <emphasis>Data Transfer
          Objects</emphasis>.</para>
      <para>TODO: expand this section when the User Interface DSL is nearer to completion.</para>
    </section>
    <section>
      <title>Service Layer</title>
      <para>The primary responsibility of the <emphasis>Service Layer</emphasis> is to isolate the
        business layer from the various protocols in use for remotely invoking its service
        operations. Examples of such protocols are SOAP or RESTful Web Services, messaging, EJB, RMI
        or plain old local mehod calls. A service layer presents the interface of the business layer
        in the form required for one particular access protocol. Therefore, a separate service layer
        is needed for each protocol by which the system will be accessed. This makes it clear that
        the presentation layer should not contain any business functionality, because that would
        have to be duplicated for each separate service layer.</para>
      <para>In addition, the service layer is reponsible for:<itemizedlist>
          <listitem>
            <para>authentication and authorisation of the calling identities</para>
          </listitem>
          <listitem>
            <para>exposing a collection of <emphasis>Data Transfer Objects</emphasis> to be used for
              transferring data between the service layer and its callers</para>
          </listitem>
          <listitem>
            <para>translation of the information in the data transfer objects used for communication
              with the presentation layer to and from <emphasis>Domain Model</emphasis> objects used
              for communication with the business layer</para>
          </listitem>
          <listitem>
            <para>making the call to each service operation an atomic (ACID) transaction.</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Data Transfer Objects</title>
        <para>TODO: describe the strategy of the Data Transfer Objects: scope, references, lazy
          loading.</para>
      </section>
    </section>
    <section>
      <title>Business Layer</title>
      <para>The <emphasis>Business Layer</emphasis> is a <emphasis>facade</emphasis> for the
          <emphasis>Domain Model</emphasis>. It exposed the business functionality of the
        application in the form of methods, with arguments and return values from the domain model.
        These methods:<itemizedlist>
          <listitem>
            <para>persist and retrieve domain objects by delegating to the <emphasis>Data
                Layer</emphasis></para>
          </listitem>
          <listitem>
            <para>delegate to domain model objects to execute reusable business functionality</para>
          </listitem>
          <listitem>
            <para>implement business logic specific to a single business process</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Data Layer</title>
      <para>The responsibility of the <emphasis>Data Layer</emphasis> is to persist and retrieve
        data. The data is transferred between the data layer and its calling business layer in the
        form of arguments and return values based on the domain model. The persistence logic is
        dependent on the particular persistence technology in use, like a relational database,
        textfiles, XML documents or an XML database, or another application that exposes services
        for accessing data.</para>
      <para>The data layer contains a number of data access objects, in principle one for each
        domain model class. Each such object:<itemizedlist>
          <listitem>
            <para>Has CRUD-methods to create (C), retrieve (R), update (U) or delete (D) data
              contained in one domain model object</para>
          </listitem>
          <listitem>
            <para>Can have methods to retrieve a list of objects based on a query</para>
          </listitem>
          <listitem>
            <para>Must transform data from the domain model to the format in which they are
              persisted, and vice versa. When a relational database is used, this may be done with a
              Object-Relational Mapping (ORM) framework, like <emphasis role="italic"
                >Hibernate</emphasis> or <emphasis role="italic">Toplink</emphasis>.</para>
          </listitem>
          <listitem>
            <para>Can offer paging facilities when a large result set may be retrieved.</para>
          </listitem>
          <listitem>
            <para>May not maintain state.</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Domain Model</title>
      <para>The <emphasis>Domain Model</emphasis> contains objects that model the part of the world
        that is of interest to the application. The domain model is preferably developed in an
        object oriented way as advocated by <biblioref linkend="fowler02"/> and <biblioref
          linkend="evans03"/>. As much business functionality as possible is implemented as methods
        on domain model classes. Domain model objects:<itemizedlist>
          <listitem>
            <para>Should expose methods that perform business actions or complex
              computations.</para>
          </listitem>
          <listitem>
            <para>Should not be aware of persistence-related issues. Domain model objects should not
              have to worry about whether or not they are persisted, and how. For instance: they
              should not have create, retrieve, update or delete methods.</para>
          </listitem>
          <listitem>
            <para>Trigger validation of business rules at any state change. Business rule violations
              are reported by raising an exception. When more than one business rule is violated by
              a state change, only one exception is raised that contains information about each
              one.</para>
          </listitem>
          <listitem>
            <para>May leave the validation of certain types of business rule to lower layers, like
              the database. Good candidates for instance are unique rules, that are easily enforced
              by a relational database by defining unique constraints. The downside of this approach
              is that business rule violations in these cases are raised at a different moment than
              ordinary business, and that they have to be treated differently.</para>
          </listitem>
          <listitem>
            <para>May trigger events to notify other interested objects of state changes.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </chapter>
  <chapter>
    <title>Implementation View</title>
    <para>This chapter describes how the architectural layers described in the previous chapter are
      implemented in the application generated by mod4j from the models. It describes which modules
      are created, how the Java classes are organised in packages, which frameworks are being used
      and in what way.</para>
    <section>
      <title>Modules</title>
      <para>The application is implemented as a <emphasis role="italic">
          <ulink url="http://maven.apache.org/">maven</ulink>
        </emphasis> project, consisting of a <emphasis role="italic">parent</emphasis> project of
        type <emphasis role="italic">pom</emphasis>, and a number of modules, one for each layer of
        the Logical View. The modules are contained in subdirectories of the directory of the parent
        project.</para>
      <para>The names of the modules are formed by concatenating the mod4j Project Name, a dash
        ("-") and a keyword derived from the architectural layer the module implements. For a
        hypothetical mod4j project "RecordShop", the module names would be: <literal
          >RecordShop-service</literal>, <literal>RecordShop-business</literal>, <literal
          >RecordShop-data</literal> and <literal>RecordShop-domain</literal>.</para>
      <para>The maven project can be built by maven from the command-line. Alternatively, the
        modules may be imported into Eclipse with the <emphasis role="italic">
          <ulink url="http://code.google.com/p/q4e/">Q4E</ulink>
        </emphasis>-plugin, and built from within Eclipse.</para>
    </section>
    <section>
      <title>Packages</title>
      <para>The Java classes are organised in Java packages all prefixed with a root package name
        provided by the user at the time the mod4j project was created by the mod4j Project Creation
        Wizard, and stored in the file <filename>src/model/mod4j.properties</filename> as the value
        of the property <varname>rootPackage</varname>. The packages names below this common prefix
        start with a package name corresponding with the component name, that in turn is derived
        from the architectural layer that it implements.</para>
      <table>
        <title>Packages</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <package>service</package>
              </entry>
              <entry>Interfaces and implementations of the service layer.</entry>
            </row>
            <row>
              <entry>
                <package>service.dto</package>
              </entry>
              <entry>Data Transfer Objects.</entry>
            </row>
            <row>
              <entry>
                <package>service.dto.translators</package>
              </entry>
              <entry>Java classes that translate Domain Objects to Data Transfer Objects, and vice
                versa.</entry>
            </row>
            <row>
              <entry>
                <package>business</package>
              </entry>
              <entry>Interfaces and implementations of the Domain Services in the business
                layer.</entry>
            </row>
            <row>
              <entry>
                <package>data</package>
              </entry>
              <entry>Interfaces that define the contracts of the Data Access Objects.</entry>
            </row>
            <row>
              <entry>
                <package>data.spring.hibernate</package>
              </entry>
              <entry>Spring/Hibernate specific implementations of the Data Access Object interfaces
                in the <package>data</package> package.</entry>
            </row>
            <row>
              <entry>
                <package>domain</package>
              </entry>
              <entry>Domain Objects: POJO classes that implement the Domain Model.</entry>
            </row>
            <row>
              <entry>
                <package>domain.businessrules</package>
              </entry>
              <entry>Java classes that implement Business Rules.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section>
      <title>Spring</title>
      <para>The Spring framework is used as a general application framework. The objects making up
        the application are being wired up by the Spring framework based on a number of XML
        configuration files, generally one per layer. The Spring
          <classname>ContextSingletonBeanFactoryLocator</classname> class is used to create multiple
        hierarchical Spring IoC container instances from these XML configuration files. For the
        container of each layer, the container of the lower layer is the parent container. This
        hierarchical container is then used as the parent container of a web application container.
        In this way, containers and the beans contained in them, may be shared between several web
        applications, and loaded only once. See section <citetitle>3.9 Glue code and the evil
          singleton</citetitle> in <biblioref linkend="spring25"/> and the Javadoc for
          <classname>ContextSingletonBeanFactoryLocator</classname> for more details.</para>
    </section>
    <section>
      <title>Hibernate</title>
      <para/>
    </section>
  </chapter>
</book>
