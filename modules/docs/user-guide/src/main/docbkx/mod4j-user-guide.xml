<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4/EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY emptysubclass-pattern SYSTEM "images/base-emptysubclass-pattern.gif" NDATA GIF>
<!ENTITY emptysubclass-domain SYSTEM "images/base-emptysubclass-domain.gif" NDATA GIF>
<!ENTITY emptysubclass-data SYSTEM "images/base-emptysubclass-data.gif" NDATA GIF>
]>
<book lang="en">
  <bookinfo>
    <title>mod4j User Guide</title>

    <authorgroup>
      <author>
        <firstname>Jos</firstname>

        <surname>Warmer</surname>
      </author>

      <author>
        <firstname>Eric Jan</firstname>

        <surname>Malotaux</surname>
      </author>

      <author>
        <firstname>Johan</firstname>

        <surname>Vogelzang</surname>
      </author>
    </authorgroup>

    <releaseinfo>0.9</releaseinfo>

    <copyright>
      <year>2008</year>

      <holder>Ordina J-Technologies</holder>
    </copyright>
  </bookinfo>

    <chapter>
      <title>Mod4j Principles and Patterns</title>

      <section>
        <title>Principles</title>

        <para>It is important to understand the principles behind the mod4j
        project. These principles have guided how the DSL's are designed and
        how they should be used. </para>

        <itemizedlist>
          <listitem>
            <para>The goal of a model is to generate code. Thus, everything in
            a model is used in some way to generate code. We don't do modeling
            for the sake of modeling.</para>
          </listitem>

          <listitem>
            <para>Model and code live side by side. That is, we do not focus
            on 100 percent code generation. Instead we focus on modeling
            aspects from which as much code as possible can be generated. At
            the same time we keep using code for aspects that are as much work
            in codee as they are in a model. Given the time constraints that
            we all have, we start with the modeling concepts that give the
            best ratio of model-to-code.</para>
          </listitem>

          <listitem>
            <para>Generated code is never overwritten, in other words
            <emphasis>the model is always leading</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Generated code is designed and generated with
            <emphasis>specific extension points</emphasis>. These extension
            points are the only places where handwritten code may be placed.
            In most cases an extension point is in a separate file than the
            generates code. To help the developer a first empty extension
            point file is usually created , but only when the expension point
            file does not exist.</para>
          </listitem>

          <listitem>
            <para>DSL"s and DSL models are independent of each other. They may
            referen through soft references, but are never hard-linked to each
            other. Thids allows both DSL models and DSLs to be developed
            separately. It also allows version management by common tools as
            CVS or subversion.</para>
          </listitem>

          <listitem>
            <para>DSL Models remain small. We do not need to handle huge
            models bevcause models are always divided into small, independent
            parts which we call DSL models. The relationbshio between those
            DSL models i done by symbolic integration of the mdoels. See the
            section on Crossx.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Code Generation Patterns</title>

        <para>The code generated by mod4j is designed to be extensible by
        handwritten code,. This allows the developer maximum flexibility.
        These so-called extension points are designed in such a way that a
        developer necver needs to overwerite generated code, he always extands
        it. This ensures that code can always be regeneretd keeping the model
        as the source for development during the lifetime of an
        application.</para>

        <para>This section describes a number of code generation patterns that
        are used in the various code generators. These patters are applied in
        the code generators of the various DSLs.</para>

        <section id="section-emptysubclass-pattern">
          <title id="empty">Empty Subclass Pattern</title>

          <para>The problem is twofold:</para>

          <itemizedlist>
            <listitem>
              <para>handwritten code may get lost when re-generating code from
              a model</para>
            </listitem>

            <listitem>
              <para>generated code may somteimes not do exactly what is
              needed</para>
            </listitem>
          </itemizedlist>

          <para>Solution:</para>

          <para>Separate the handwritten and generated code in separate
          classes / files. Generate an abstract base class that contains all
          code that is generated. Generate an empty subclass in a separate
          file. In this way the generator may always regenerate the base class
          with all generated code, while it will never regenerate the subclass
          file with handwritten code.</para>

          <para>The handwritten subclass file is used for two purposes:</para>

          <itemizedlist>
            <listitem>
              <para>Extend the generated code in the base class with things
              that cannot be generated from the model. In this case the base
              class usually defines something like an abstract method such
              that this must be defined in the handwritten file</para>
            </listitem>

            <listitem>
              <para>Overwrite a method in the generated base class. This
              allows a developer to overrule the generated code. The system
              depends to a great extent on assumptions about the generated
              code. Therefore the developer should be intimitely aware of the
              consequences and only use this in exceptional cases. </para>
            </listitem>
          </itemizedlist>

          <para>The empty-subclass pattern is used at several places within
          Mod4j. It is a well known pattern in Java code generation and allows
          a clear separation of generated and handwritten code. Code generated
          for a Java class or java interface is done in two parts. An abstract
          base class is generated which conmtains all the generated code. An
          empty concrete subclass is generated. handwritten code should be put
          into this subclass.</para>

          <para>The generator will always regenerate the abstract baseclass.
          The generator will only generate the empty subclass once, if it is
          not there. In this way handwritten code is never overwritten by the
          code generator.</para>

          <para>The solution is shown in <xref
          linkend="emptysubclass-pattern" />.</para>

          <para></para>

          <figure id="emptysubclass-pattern">
            <title id="titleid">Empty dubclass pattern</title>

            <mediaobject>
              <imageobject>
                <imagedata entityref="emptysubclass-pattern" format="GIF" />
              </imageobject>
            </mediaobject>
          </figure>

          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/base-emptysubclass-pattern.gif"
                           format="GIF" />
              </imageobject>
            </mediaobject>
          </informalfigure>

          <para>There are a few porperties of this solution that we need to be
          aware of:</para>

          <orderedlist>
            <listitem>
              <para>The empty subclass isn't completely empty. It needs to
              include the public constructors from the base class with a calls
              to super(). This means that whenever the generated constructors
              change, the constructors in the subclass will be
              outdated.</para>
            </listitem>

            <listitem>
              <para>When the abstract base class isnt generated anymore, the
              empty subclass will become superfluous. It refers to a
              non-existing base class. The java compiler will flag this as an
              error, and the developer needs to remove the subclass by
              hand.</para>
            </listitem>
          </orderedlist>
        </section>
      </section>
    </chapter>

    <chapter>
    <title>Business Domain DSL</title>

      <section>
        <title>Purpose</title>

        <para>The Business Domain DSL is intended to be use for modeling the
        domain model of an application. De Busines Domain model consists of
        all domain classes, as understood by the business expert. Technical
        aspects do not belong in Business Domain models.</para>

        <para>From a business domain model code is generated, conforming to
        the reference architecture as describe in REF. As a consequence, the
        code will alsways conform perfectly to the architecture, ensuring a
        high quality application.</para>

        <para>This document describes the concepts as they are defined in the
        language and how they can be used to specify a business domain
        model.</para>
      </section>

      <section>
        <title>Principles</title>

        <para>The principles behind the mod4j project are important to
        understand how the DSL's are designed and how they should be
        used.</para>

        <itemizedlist>
          <listitem>
            <para>The goal of a model is to generate code. Thus, everything in
            a model is used in some way to generate code.</para>
          </listitem>

          <listitem>
            <para>Model and code live side by side. That is, we do not focus
            on 100 percent code generation. Instead we focus on modeling
            aspects from which much code can be genmerated, while coding
            aspects that are as much work in codee as it is in a model. Given
            the time constraint6s that we all have, we start with the modeling
            concepts that give the best ratio of model-to-code.</para>
          </listitem>

          <listitem>
            <para>Generated code is never overwritten. Within the generated
            code specific extension point are generated. These extension
            points are the only places where handwritten code may be placed.
            In most cases an extension point is in a separete file than the
            generatee code. To help the developer a first empty extension
            point file is usually created , but only when the expension point
            file does not exist.</para>
          </listitem>

          <listitem>
            <para>DSL"s and DSL models are independent of each other. They may
            referen through soft references, but are never hard-linked to each
            other. Thids allows both DSL models and DSLs to be developed
            separately. It also allows version management by common tools as
            CVS or subversion.</para>
          </listitem>
        </itemizedlist>
      </section>
    </chapter>

    <chapter>
      <title>Reference</title>

      <para></para>

      <section>
        <title>Business Class</title>

        <section>
          <title>Definition</title>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve"><keycap>Class</keycap> Person [
    // properties go here ...
    // rules go here ...
]
</programlisting>

          <para>A Business Class describes something that has a specific
          meaning in the buiness domain being modeled. In the system being
          modeled instances of business classes will be created.</para>

          <para>A business class has properties (also called attributes in
          e.g. UML) of diferent types.</para>

          <para>A busines class also contains business rules, that specify the
          conditions that an instance of the class needs to conform to.</para>
        </section>

        <section>
          <title>Generated code</title>

          <para>For a business class code is generated for both the domain and
          the data layer of the architecture.</para>

          <section>
            <title>Domain Layer</title>

            <para>In the domain code is generated according to the
            <emphasis>empty baseclass pattern </emphasis>(<xref
            linkend="section-emptysubclass-pattern" />). For each
            businessclass two Java classes are generated. The first Java class
            is an abstract base class containing all generated code for the
            business class. All code generated for properties, associations
            and business rules is placed inside this class.</para>

            <para>The second class generated is an empty (except for
            constructors calling <code>super()</code>) class which subclasses
            the first class. This empty class is what we call an
            <emphasis>extension point </emphasis>file, where manual code may
            be added. This extension class is generated once and not
            overwritten, which ensures that all handwritten code is maintained
            at all times.</para>

            <figure id="figure-emptysubclass-domain">
              <title>Empty subclass pattern applied to the Domain
              Layer</title>

              <mediaobject>
                <imageobject>
                  <imagedata entityref="emptysubclass-domain" format="GIF" />
                </imageobject>
              </mediaobject>
            </figure>

            <informalfigure>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/base-emptysubclass-domain.gif"
                             format="GIF" />
                </imageobject>
              </mediaobject>
            </informalfigure>
          </section>

          <section>
            <title>Data Layer</title>

            <para>In the datalayer a number of files is generated.</para>

            <para>A hibernate mapping file is generated for each
            businessclass.</para>

            <para>One Hibernate ???? (how do you call this DatalaagContext.xml
            file) file is generated for the application as a whole.</para>

            <para>A Dao (Data Acces layer) is generated. The dao normally
            consists of one interface and an implementing class. To get a
            clean separation of generated and handwritten code both of these
            use the empty subclass pattern. The result for a class called
            Person is shown in figure <xref
            linkend="figure-emptysubclass-data" />. Note that this is another
            instance of the empty subclass patternb as described in <xref
            linkend="section-emptysubclass-pattern" />.</para>

            <figure id="figure-emptysubclass-data">
              <title>Empty subclass pattern applied to the Data Layer</title>

              <mediaobject>
                <imageobject>
                  <imagedata entityref="emptysubclass-data" format="GIF" />
                </imageobject>
              </mediaobject>
            </figure>

            <informalfigure>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="images/base-emptysubclass-data.gif"
                             format="GIF" />
                </imageobject>
              </mediaobject>
            </informalfigure>
          </section>
        </section>
      </section>

      <section>
        <title>Properties</title>

        <section>
          <title>Definition</title>

          <para>Properties look like this.</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve"><keycap>Class</keycap> Person [
    <keycap>string</keycap>   name;
    <keycap>integer</keycap>  numberOfEars;
    <keycap>datetime</keycap> birthdate;
    <keycap>decimal</keycap>  length;
    <keycap>boolean</keycap>  isMale;
    // rules go here ...
]
</programlisting>

          <para>A property descibes a characteristic of a business class.
          Properties always have a type. Each instance of a business class has
          its own values for each propertyA property can have a predefined
          type, which can be <emphasis>integer</emphasis>,
          <emphasis>string</emphasis>, <emphasis>decimal</emphasis>,
          <emphasis>boolean</emphasis> or <emphasis>datetime</emphasis>. For
          each type specific constraints can be specified. These constraints
          must always be true for any value of the property.</para>
        </section>

        <section>
          <title>Generated code</title>

          <para>For a property code is generated for both the domain and the
          data layer of the architecture.</para>

          <para>In the domain code is generated according to the Empty
          baseclass pattern (REF). For each businessclass an abstract baes
          class is generated. This code contains a field for the property and
          getter and setter methods. If the there are constaints speciified
          for the property in the model, validators for the proprty are also
          generated. Code is also generated to automatically call the
          validator whenever the value fo the property has changed, e.g. when
          calling the setter method.</para>

          <para>An empty subclass is also generated as an extension point for
          handwritten code.</para>

          <section>
            <title>String Attribute</title>

            <para>A string attribute is completely denoted as shown
            below</para>

            <programlisting class="monospaced" continuation="continues"
                            format="specific" linenumbering="numbered"
                            xml:space="preserve">"A readable description of this attribute
<keycap>string</keycap> name
      <keycap>default</keycap> "the default name"
      <keycap>minlength</keycap> 3 
      <keycap>maxlength</keycap> 10 
      <keycap>regexp</keycap> "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$"
      <keycap>nullable</keycap> ;

</programlisting>

            <para>Each attribute can have a description, which is places
            directly before the attribute definition. Each string attribute
            has a number of optional properties, as shown above. The order of
            the properties is fexed as shown. These properties act as
            constraints on the value of the attribute and are explained
            below..</para>

            <glosslist>
              <glossentry>
                <glossterm>defauilt</glossterm>

                <glossdef>
                  <para>Defines the default value of thsi attribute. This
                  value is assigned when the object is being created. The
                  value may change later on in the Objects lifetime.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>minlengt</glossterm>

                <glossdef>
                  <para>Defines the minimal number of characters of this
                  attribute's value.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>maxlenght</glossterm>

                <glossdef>
                  <para>Defined the maximum number of characters of this
                  attribute's value.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>regexp</glossterm>

                <glossdef>
                  <para>Defines the format of the attribute's value through a
                  regular expression. The syntax of the reguar expression is
                  defined by REF.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>nullable</glossterm>

                <glossdef>
                  <para>The nullable property specifies that this attribute
                  does not have to have a value. If nullable is no specified,
                  the attribute must always have a defined value..</para>
                </glossdef>
              </glossentry>
            </glosslist>

            <section>
              <title>Generated code</title>

              <para></para>
            </section>
          </section>

          <section>
            <title>Boolean Attribute</title>

            <para>A boolean attribute is completely denoted as shown
            below</para>

            <programlisting class="monospaced" continuation="continues"
                            format="specific" linenumbering="numbered"
                            xml:space="preserve">"A readable description of this attribute"
<keycap>boolean</keycap> fixed
      <keycap>default</keycap> "true"
      <keycap>nullable</keycap> ;

</programlisting>

            <para>Each attribute can have a description, which is places
            directly before the attribute definition. Each boolean attribute
            has a number of optional properties, as shown above. The order of
            the properties is fixed. These properties act as constraints on
            the value of the attribute and are explained below..</para>

            <glosslist>
              <glossentry>
                <glossterm>defauilt</glossterm>

                <glossdef>
                  <para>Defines the default value of this attribute. This
                  value is assigned when the object is being created. The
                  value may change later on in the Objects lifetime.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>nullable</glossterm>

                <glossdef>
                  <para>The nullable property specifies that this attribute
                  does not have to have a value. If nullable is no specified,
                  the attribute must always have a defined value.</para>
                </glossdef>
              </glossentry>
            </glosslist>
          </section>

          <section>
            <title>Integer Attribute</title>

            <para>An integer attribute is completely defined as shown
            below</para>

            <programlisting class="monospaced" continuation="continues"
                            format="specific" linenumbering="numbered"
                            xml:space="preserve">"A readable description of this attribute"
<keycap>integer </keycap>numberOfSteps
      <keycap>default</keycap> 12
      <keycap>min</keycap> 4
      <keycap>max</keycap> 32
      <keycap>nullable</keycap> ;

</programlisting>

            <para>A integer attribute has a number of optional properties, as
            shown above. The order of the properties is fixed. These
            properties act as constraints on the value of the attribute and
            are explained below..</para>

            <glosslist>
              <glossentry>
                <glossterm>defauilt</glossterm>

                <glossdef>
                  <para>Defines the default value of this attribute. This
                  value is assigned when the object is being created. The
                  value may change later on in the Objects lifetime.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>min</glossterm>

                <glossdef>
                  <para>Defines the minimal value of this attribute.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>max</glossterm>

                <glossdef>
                  <para>Defines the maximum value of this attribute.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>nullable</glossterm>

                <glossdef>
                  <para>The nullable property specifies that this attribute
                  does not have to have a value. If nullable is no specified,
                  the attribute must always have a defined value.</para>
                </glossdef>
              </glossentry>
            </glosslist>
          </section>

          <section>
            <title>Decimal Attribute</title>

            <para>An decimal attribute is completely defined as shown
            below</para>

            <programlisting class="monospaced" continuation="continues"
                            format="specific" linenumbering="numbered"
                            xml:space="preserve">"A readable description of this attribute"
<keycap>decimal</keycap> percentage
      <keycap>default</keycap> 12
      <keycap>min</keycap> 4
      <keycap>max</keycap> 32
      <keycap>nullable</keycap> ;

</programlisting>

            <para>A decimal attribute has a number of optional properties, as
            shown above. The order of the properties is fixed. These
            properties act as constraints on the value of the attribute and
            are explained below..</para>

            <glosslist>
              <glossentry>
                <glossterm>defauilt</glossterm>

                <glossdef>
                  <para>Defines the default value of this attribute. This
                  value is assigned when the object is being created. The
                  value may change later on in the Objects lifetime.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>min</glossterm>

                <glossdef>
                  <para>Defines the minimal value of this attribute.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>max</glossterm>

                <glossdef>
                  <para>Defines the maximum value of this attribute.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>nullable</glossterm>

                <glossdef>
                  <para>The nullable property specifies that this attribute
                  does not have to have a value. If nullable is no specified,
                  the attribute must always have a defined value.</para>
                </glossdef>
              </glossentry>
            </glosslist>
          </section>

          <section>
            <title>Datetime Attribute</title>

            <para>An datetime attribute is completely defined as shown
            below</para>

            <programlisting class="monospaced" continuation="continues"
                            format="specific" linenumbering="numbered"
                            xml:space="preserve">"A readable description of this attribute"
<keycap>datetime day</keycap> started
    <keycap>  <keycap>default</keycap></keycap> 4
      <keycap>nullable</keycap> ;

</programlisting>

            <para>A datetime attribute has a number of optional properties, as
            shown above. The order of the properties is fixed. These
            properties act as constraints on the value of the attribute and
            are explained below..</para>

            <glosslist>
              <glossentry>
                <glossterm>accuray</glossterm>

                <glossdef>
                  <para>Defines the accuracy of the datetime attribute. The
                  possible values are year, month, day, hour, minute, second,
                  millisecond. In the above example the accuracy is defined as
                  day.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>default</glossterm>

                <glossdef>
                  <para>Defines the default value of this attribute.</para>
                </glossdef>
              </glossentry>

              <glossentry>
                <glossterm>nullable</glossterm>

                <glossdef>
                  <para>The nullable property specifies that this attribute
                  does not have to have a value. If nullable is no specified,
                  the attribute must always have a defined value.</para>
                </glossdef>
              </glossentry>
            </glosslist>
          </section>
        </section>
      </section>

      <section>
        <title>Enumerations</title>

        <para>An enumeration defines a datatype which can be used as the type
        of an attibute of a business class. The enumeration definition
        includes a list of all enumeration values. The example below shown an
        enumeration definition.</para>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve">"The severity level of a customer problem"
<keycap>Enumeration</keycap> SeverityLevel [
    Low    = 1;
    Middle = 2;
    High   = 3;
]
</programlisting>

        <para>The "= 1" ets defines the numeric value that is used for the
        enumeration literal in the code and the database. This is optional,
        but useful when you need to address existing encoding schemes for
        enumerations.</para>
      </section>

      <section>
        <title>Business Rules</title>

        <para>A business class may include business rules. Note that the
        conceopt of business rule here is limited. In this context a business
        rule is a rule that should be true at all times for every object of
        the given business class.</para>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve"><keycap>Class</keycap> SampleClass [
    // properties go here ...
    // rules go here ...
    <keycap>Rules</keycap> [
        "A first rule
        mustBeValid;
        "A second rule"
        isOriginal;
       <keycap>unique</keycap> namesUnique [ firstname lastname ]
    ]
]
</programlisting>

        <para>There are twom types of busienssrules that can be
        modeled.</para>

        <para>The first type of businessrule only has a name in the model. The
        actual implementation of the rule must be written in Java as an
        extension to the generated code.</para>

        <para>The handling of the rule is completely generated. This means
        that the rule will be called and validated whenever the object
        changes. If the rule is broken, a BusinessClassException is
        created.</para>

        <para></para>

        <para>See the empty-subclass pattern on how this is done in the
        code</para>
      </section>

      <section>
        <title>Associations</title>

        <para>The final part of a domain model defines all the relationship,s
        beteenm the bsuiness classes.</para>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve"><keycap>Association</keycap> customer Customer [0..1] &lt;-&gt; [0..*] orders     Order    ;
<keycap>Association</keycap> order    Order    [0..1]  -&gt; [0..*] orderLines OrderLine;
</programlisting>

        <para>This example shows</para>
      </section>
    </chapter>
</book>
