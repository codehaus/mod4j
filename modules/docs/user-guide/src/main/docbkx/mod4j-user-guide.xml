<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4/EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY emptysubclass-pattern SYSTEM "images/base-emptysubclass-pattern.jpg" NDATA JPG>
<!ENTITY emptysubclass-domain SYSTEM "images/base-emptysubclass-domain.jpg" NDATA JPG>
<!ENTITY emptysubclass-data SYSTEM "images/base-emptysubclass-data.jpg" NDATA JPG>
]>
<book lang="en">
  <bookinfo>
    <title>mod4j User Guide</title>

    <authorgroup>
      <author>
        <firstname>Jos</firstname>

        <surname>Warmer</surname>
      </author>

      <author>
        <firstname>Eric Jan</firstname>

        <surname>Malotaux</surname>
      </author>

      <author>
        <firstname>Johan</firstname>

        <surname>Vogelzang</surname>
      </author>
    </authorgroup>

    <releaseinfo>1.0 beta</releaseinfo>

    <copyright>
      <year>2008</year>

      <holder>Ordina J-Technologies</holder>
    </copyright>
  </bookinfo>

  <chapter>
    <title>Mod4j Principles and Patterns</title>

    <section>
      <title>Principles</title>

      <para>It is important to understand the principles behind the mod4j
      project. These principles have guided how the DSL's are designed and how
      they should be used.</para>

      <section>
        <title>Code Generation Principles</title>

        <para>Code generation has been around for a long time. Mod4j takes in
        account many of the lessons learned. The following principles are
        guiding the Mod4j development.</para>

        <itemizedlist>
          <listitem>
            <para><keycap>Generated code must be clear and readable</keycap>.
            Using Mod4j should noit be a lifetime commitment. Thgerefopre the
            source code must eb at least as good as handwritten code. This
            allows projects to continue development with the generated code
            instead of the DSL models. Note that this surely isn;t the
            recommended way, but we like the freedom this gives.</para>

            <para>Another reason for generating clear and readable code is
            that we do not have debuggers at the model level. This would be
            great, but the tools to develop model-level debuggers are not
            avialable (yet, we hope). Therefore code neesvto be debugged at
            the source code level and having eadable generated code really
            helps.</para>

            <para>The third reason for generating clear code is that we do not
            generate everything. We support a mizxe-mode development where
            developers write boith models and code to extend the generated
            code. It is easier to extend generated cod when this is
            readable.</para>
          </listitem>

          <listitem>
            <para><keycap>Generated code is never overwritten</keycap>, in
            other words <emphasis>the model is always
            leading</emphasis>.</para>
          </listitem>

          <listitem>
            <para>To ensure that generated code bever needs to be overwritten
            the generated code is designed and generated with
            <emphasis>specific extension points</emphasis>. These extension
            points are the only places where handwritten code may be placed.
            In most cases an extension point is in a separate file than the
            generates code. To help the developer a first empty extension
            point file is usually created , but only when the expension point
            file does not exist.</para>
          </listitem>

          <listitem>
            <para><keycap>Within Eclipse Mod4j support incremental code
            generation</keycap>. This means that code is generated on a per
            model file basis. Effectively whenever a model file is saved the
            code for this model file is generated automatically in the
            background. There is no need for a separate code generation step.
            This code generation step uses the ard Eclipse build strcuture. If
            the n 'build automatically' is set this will happen. If a full
            build is requested all code will be regenerated. This allows
            Eclipse users to work with models in the same way as with source
            code (i.e. Java class files).</para>
          </listitem>

          <listitem>
            <para><keycap>Code generation through Maven.</keycap> Mod4j
            includes a Maven plugin that support the code generation process
            in batch mode. This is used to run automatics builds based on thge
            models. There is no need to checkin generated source code, just as
            there is noi need to checkin compiled Java classesWe support two
            ways of generating code.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Modeling Principles</title>

        <para>Modeling in Mod4j is:<itemizedlist>
            <listitem>
              <para><keycap>The goal of a model is to generate code.</keycap>
              Thus, everything in a model is used in some way to generate
              code. We don't do modeling for the sake of modeling.</para>
            </listitem>

            <listitem>
              <para>Model and code live side by side. That is, we do not focus
              on 100 percent code generation. Instead we focus on modeling
              aspects from which as much code as possible can be generated. At
              the same time we keep using code for aspects that are as much
              work in codee as they are in a model. Given the time constraints
              that we all have, we start with the modeling concepts that give
              the best ratio of model-to-code.</para>
            </listitem>

            <listitem>
              <para><keycap>DSL"s and DSL models are independent of each
              other</keycap>. They may reference through soft references, but
              are never hard-linked to each other. This allows both DSL models
              and DSLs to be developed separately. It also allows version and
              multi-user management by common tools as CVS or
              subversion.</para>
            </listitem>

            <listitem>
              <para><keycap>DSL Models are and remain remain small.</keycap>
              We do not need to handle huge models bevcause models are always
              divided into small, independent parts which we call DSL models.
              The relationbshio between those DSL models i done by symbolic
              integration of the mdoels. See the section on Crossx.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>

    <section>
      <title>Code Generation Patterns</title>

      <para>The code generated by mod4j is designed to be extensible by
      handwritten code,. This allows the developer maximum flexibility. These
      so-called extension points are designed in such a way that a developer
      necver needs to overwerite generated code, he always extands it. This
      ensures that code can always be regeneretd keeping the model as the
      source for development during the lifetime of an application.</para>

      <para>This section describes a number of code generation patterns that
      are used in the various code generators. These patters are applied in
      the code generators of the various DSLs.</para>

      <section id="section-emptysubclass-pattern">
        <title id="empty">Generation Gap Pattern or Empty Subclass
        Pattern</title>

        <para>The problem is twofold:</para>

        <itemizedlist>
          <listitem>
            <para>handwritten code may get lost when re-generating code from a
            model</para>
          </listitem>

          <listitem>
            <para>generated code may somteimes not do exactly what is
            needed</para>
          </listitem>
        </itemizedlist>

        <para>Solution:</para>

        <para>Separate the handwritten and generated code in separate classes
        / files. Generate an abstract base class that contains all code that
        is generated. Generate an empty subclass in a separate file. In this
        way the generator may always regenerate the base class with all
        generated code, while it will never regenerate the subclass file with
        handwritten code.</para>

        <para>The handwritten subclass file is used for two purposes:</para>

        <itemizedlist>
          <listitem>
            <para>Extend the generated code in the base class with things that
            cannot be generated from the model. In this case the base class
            usually defines something like an abstract method such that this
            must be defined in the handwritten file</para>
          </listitem>

          <listitem>
            <para>Overwrite a method in the generated base class. This allows
            a developer to overrule the generated code. The system depends to
            a great extent on assumptions about the generated code. Therefore
            the developer should be intimitely aware of the consequences and
            only use this in exceptional cases.</para>
          </listitem>
        </itemizedlist>

        <para>The empty-subclass pattern is used at several places within
        Mod4j. It is a well known pattern in Java code generation and allows a
        clear separation of generated and handwritten code. Code generated for
        a Java class or java interface is done in two parts. An abstract base
        class is generated which conmtains all the generated code. An empty
        concrete subclass is generated. handwritten code should be put into
        this subclass.</para>

        <para>The generator will always regenerate the abstract baseclass. The
        generator will only generate the empty subclass once, if it is not
        there. In this way handwritten code is never overwritten by the code
        generator.</para>

        <para>The solution is shown in <xref
        linkend="emptysubclass-pattern" />.</para>

        <para></para>

        <figure id="emptysubclass-pattern">
          <title id="titleid">Empty dubclass pattern</title>

          <mediaobject>
            <imageobject>
              <imagedata contentwidth="100" entityref="emptysubclass-pattern"
                         format="JPG" />
            </imageobject>
          </mediaobject>
        </figure>

        <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/base-emptysubclass-pattern.jpg"
                         format="JPG" />
            </imageobject>
          </mediaobject>
        </informalfigure>

        <para>There are a few porperties of this solution that we need to be
        aware of:</para>

        <orderedlist>
          <listitem>
            <para>The empty subclass isn't completely empty. It needs to
            include the public constructors from the base class with a calls
            to super(). This means that whenever the generated constructors
            change, the constructors in the subclass will be outdated.</para>
          </listitem>

          <listitem>
            <para>When the abstract base class isnt generated anymore, the
            empty subclass will become superfluous. It refers to a
            non-existing base class. The java compiler will flag this as an
            error, and the developer needs to remove the subclass by
            hand.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Business Domain DSL</title>

    <section>
      <title>Purpose</title>

      <para>The Business Domain DSL is intended to be use for modeling the
      domain model of an application. De Busines Domain model consists of all
      domain classes, as understood by the business expert. Technical aspects
      do not belong in Business Domain models.</para>

      <para>From a business domain model code is generated, conforming to the
      reference architecture as describe in REF. As a consequence, the code
      will alsways conform perfectly to the architecture, ensuring a high
      quality application.</para>

      <para>This document describes the concepts as they are defined in the
      language and how they can be used to specify a business domain
      model.</para>
    </section>

    <section>
      <title>Principles</title>

      <para>The principles behind the mod4j project are important to
      understand how the DSL's are designed and how they should be
      used.</para>

      <itemizedlist>
        <listitem>
          <para>The goal of a model is to generate code. Thus, everything in a
          model is used in some way to generate code.</para>
        </listitem>

        <listitem>
          <para>Model and code live side by side. That is, we do not focus on
          100 percent code generation. Instead we focus on modeling aspects
          from which much code can be genmerated, while coding aspects that
          are as much work in codee as it is in a model. Given the time
          constraint6s that we all have, we start with the modeling concepts
          that give the best ratio of model-to-code.</para>
        </listitem>

        <listitem>
          <para>Generated code is never overwritten. Within the generated code
          specific extension point are generated. These extension points are
          the only places where handwritten code may be placed. In most cases
          an extension point is in a separete file than the generatee code. To
          help the developer a first empty extension point file is usually
          created , but only when the expension point file does not
          exist.</para>
        </listitem>

        <listitem>
          <para>DSL"s and DSL models are independent of each other. They may
          referen through soft references, but are never hard-linked to each
          other. Thids allows both DSL models and DSLs to be developed
          separately. It also allows version management by common tools as CVS
          or subversion.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Business Domain DSL Reference</title>

    <para>This chapter provides a description of all the concepts in the
    Business Domain DSL. each concept is described by a definition which
    explains the business meaning of the concept, and a description of the
    code generated for the concept.</para>

    <section>
      <title>Business Class</title>

      <section>
        <title>Definition</title>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve"><keycap>Class</keycap> Person [
    // properties go here ...
    // rules go here ...
]
</programlisting>

        <para>A Business Class describes something that has a specific meaning
        in the buiness domain being modeled. In the system being modeled
        instances of business classes will be created.</para>

        <para>A business class has properties (also called attributes in e.g.
        UML) of diferent types.</para>

        <para>A busines class also contains business rules, that specify the
        conditions that an instance of the class needs to conform to.</para>
      </section>

      <section>
        <title>Generated code</title>

        <para>For a business class code is generated for both the domain and
        the data layer of the architecture.</para>

        <section>
          <title>Domain Layer</title>

          <para>In the domain code is generated according to the
          <emphasis>empty baseclass pattern </emphasis>(<xref
          linkend="section-emptysubclass-pattern" />). For each businessclass
          two Java classes are generated. The first Java class is an abstract
          base class containing all generated code for the business class. All
          code generated for properties, associations and business rules is
          placed inside this class.</para>

          <para>The second class generated is an empty (except for
          constructors calling <code>super()</code>) class which subclasses
          the first class. This empty class is what we call an
          <emphasis>extension point </emphasis>file, where manual code may be
          added. This extension class is generated once and not overwritten,
          which ensures that all handwritten code is maintained at all
          times.</para>

          <figure id="figure-emptysubclass-domain">
            <title>Empty subclass pattern applied to the Domain Layer</title>

            <mediaobject>
              <imageobject>
                <imagedata entityref="emptysubclass-domain" format="JPG" />
              </imageobject>
            </mediaobject>
          </figure>

          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/base-emptysubclass-domain.jpg"
                           format="JPG" />
              </imageobject>
            </mediaobject>
          </informalfigure>
        </section>

        <section>
          <title>Data Layer</title>

          <para>In the datalayer a number of files is generated.</para>

          <para>A hibernate mapping file is generated for each
          businessclass.</para>

          <para>One Hibernate confiuguration file (how do you call this
          DatalaagContext.xml file) file is generated for the application as a
          whole.</para>

          <para>A Dao (Data Acces layer) is generated. The dao normally
          consists of one interface and an implementing class. To get a clean
          separation of generated and handwritten code both of these use the
          empty subclass pattern. The result for a class called Person is
          shown in figure <xref linkend="figure-emptysubclass-data" />. Note
          that this is another instance of the empty subclass patternb as
          described in <xref
          linkend="section-emptysubclass-pattern" />.</para>

          <figure id="figure-emptysubclass-data">
            <title>Empty subclass pattern applied to the Data Layer</title>

            <mediaobject>
              <imageobject>
                <imagedata entityref="emptysubclass-data" format="JPG" />
              </imageobject>
            </mediaobject>
          </figure>

          <informalfigure>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/base-emptysubclass-data.jpg"
                           format="JPG" />
              </imageobject>
            </mediaobject>
          </informalfigure>
        </section>
      </section>
    </section>

    <section>
      <title>Attributes</title>

      <section>
        <title>Definition</title>

        <para>Attributes are part of a business class and defined within the
        scope of their class. The example class person looks as
        follows.</para>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve"><keycap>Class</keycap> Person [
    <keycap>string</keycap>   name;  <keycap>default</keycap> "the default name"
                    <keycap>minlength</keycap> 3  <keycap>maxlength</keycap> 10 
      <keycap>              regexp</keycap> "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$"
      <keycap>              nullable</keycap> ;
    <keycap>integer</keycap>  numberOfEars;    // optional constraints
    <keycap>datetime</keycap> birthdate;       // optional constraints
    <keycap>decimal</keycap>  length;          // optional constraints
    "Description of the isMale attribute"
    <keycap>boolean</keycap>  isMale;          // optional constraints
    // rules go here ...
]
</programlisting>

        <para>A property descibes a characteristic of a business class.
        Properties always have a defined type. A property can have a
        predefined type, which can be <emphasis>integer</emphasis>,
        <emphasis>string</emphasis>, <emphasis>decimal</emphasis>,
        <emphasis>boolean</emphasis> or <emphasis>datetime</emphasis>.</para>

        <para>Each attribute can have a description, which is placed directly
        before the attribute definition within double quotes. In the example
        only isMale has a description.</para>

        <para>For each attribute additional constraints can be specified. In
        th above eample minlength, maxlength and regexp are such constraints.
        These constraints must always be true for the property.</para>

        <para>Each instance of a business class has its own values for each
        property. These values always need to conform to all the rules
        specified for the business class.</para>
      </section>

      <section>
        <title>Generated code</title>

        <para>For a property code is generated for both the domain and the
        data layer of the architecture.</para>

        <para>As described before (REF) code is generated in the domain layer
        according to the Empty baseclass pattern. For each businessclass an
        abstract base class is generated. This abstract bases class contains a
        field for eack property and getter and setter methods to access the
        property.</para>

        <para>The description of an attribute is used to generate Javadoc
        comments in the code for the attribute.</para>

        <para>If the there are constaints speciified for the property in the
        model, validators for the property are also generated. Code is also
        generated to automatically call these validators whenever the value fo
        the property has changed, e.g. when calling the setter method.
        Wheneven an attempts is made to chnage the value of a property that
        will break a constraint, a BusinessRulevalidation exception is thrown
        and the value of the attribute is not changed.</para>

        <para>If an attribute is not nullable and has no default value (see
        next sections for an explanation of nullable and default value), the
        attribute is added as a parameter to the constructor of the class.
        This ensures that an object of this class will always be
        correct.</para>

        <section>
          <title>String Attribute</title>

          <para>A string attribute is completely denoted as shown below. Note
          that all constraints (after <code>string name</code>) are
          optional.</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute
<keycap>string</keycap> name
      <keycap>default</keycap> "the default name"
      <keycap>minlength</keycap> 3 
      <keycap>maxlength</keycap> 10 
      <keycap>regexp</keycap> "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$"
      <keycap>nullable</keycap> ;

</programlisting>

          <para>Each string attribute has a number of optional properties,.
          The order of the properties is fixed as shown above. These
          properties act as constraints on the value of the attribute and are
          explained below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute. This value
                is assigned when the object is being created. The value may be
                changed later on in the objects lifetime.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>minlengt</glossterm>

              <glossdef>
                <para>Defines the minimal number of characters of this
                attribute's value.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>maxlenght</glossterm>

              <glossdef>
                <para>Defined the maximum number of characters of this
                attribute's value. The value of <emphasis>maxlength</emphasis>
                must always be higher or equal to value of
                <emphasis>minlength</emphasis>..</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>regexp</glossterm>

              <glossdef>
                <para>Defines the format of the attribute's value through a
                regular expression. The syntax of the reguar expression is
                defined by REF.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is not specified, the
                attribute must always have a defined value..</para>
              </glossdef>
            </glossentry>
          </glosslist>

          <section>
            <title>Generated code</title>

            <para>Apart from the generic code generated for each property no
            additional code is generated for a string property.</para>
          </section>
        </section>

        <section>
          <title>Boolean Attribute</title>

          <para>A boolean attribute is completely denoted as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>boolean</keycap> fixed
      <keycap>default</keycap> "true"
      <keycap>nullable</keycap> ;

</programlisting>

          <para>Each attribute can have a description, which is places
          directly before the attribute definition. Each boolean attribute has
          a number of optional properties, as shown above. The order of the
          properties is fixed. These properties act as constraints on the
          value of the attribute and are explained below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute. This value
                is assigned when the object is being created. The value may
                change later on in the Objects lifetime.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>

          <section>
            <title>Generated code</title>

            <para>A boolean attribute that is not
            <emphasis>nullable</emphasis> is implemented ny a Java
            <emphasis>boolean</emphasis> field, if the attribute is nullable
            this is done by a <emphasis>Boolean</emphasis> object
            field.</para>
          </section>
        </section>

        <section>
          <title>Integer Attribute</title>

          <para>An integer attribute is completely defined as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>integer </keycap>numberOfSteps
      <keycap>default</keycap> 12
      <keycap>min</keycap> 4
      <keycap>max</keycap> 32
      <keycap>nullable</keycap> ;

</programlisting>

          <para>A integer attribute has a number of optional properties, as
          shown above. The order of the properties is fixed. These properties
          act as constraints on the value of the attribute and are explained
          below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute. This value
                is assigned when the object is being created. The value may
                change later on in the Objects lifetime. If the
                <emphasis>min</emphasis> and/or <emphasis>max</emphasis>
                properties are specied the default value must conform to these
                properties.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>min</glossterm>

              <glossdef>
                <para>Defines the minimal value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>max</glossterm>

              <glossdef>
                <para>Defines the maximum value of this attribute. The value
                of <emphasis>max</emphasis> must always be greater or equal to
                thevalue of <emphasis>min</emphasis>.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>

        <section>
          <title>Decimal Attribute</title>

          <para>An decimal attribute is completely defined as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>decimal</keycap> percentage
      <keycap>default</keycap> 12
      <keycap>min</keycap> 4
      <keycap>max</keycap> 32
      <keycap>nullable</keycap> ;

</programlisting>

          <para>A decimal attribute has a number of optional properties, as
          shown above. The order of the properties is fixed. These properties
          act as constraints on the value of the attribute and are explained
          below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute. This value
                is assigned when the object is being created. The value may
                change later on during the objects lifetime.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>min</glossterm>

              <glossdef>
                <para>Defines the minimal value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>max</glossterm>

              <glossdef>
                <para>Defines the maximum value of this attribute. The value
                of <emphasis>max</emphasis> must always be greater or equal to
                thevalue of <emphasis>min</emphasis>.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>

        <section>
          <title>Datetime Attribute</title>

          <para>An datetime attribute is completely defined as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"The day on which it all started"
<keycap>datetime day</keycap> started
    <keycap>  <keycap>default</keycap></keycap> 4
    <keycap>  <keycap>accuracy</keycap></keycap> day
      <keycap>nullable</keycap> ;

</programlisting>

          <para>A datetime attribute has a number of optional properties, as
          shown above. The order of the properties is fixed. These properties
          act as constraints on the value of the attribute and are explained
          below..</para>

          <glosslist>
            <glossentry>
              <glossterm>accuray</glossterm>

              <glossdef>
                <para>Defines the accuracy of the datetime attribute. The
                possible values are year, month, day, hour, minute, second,
                millisecond. In the above example the accuracy is defined as
                day.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>default</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>
      </section>
    </section>

    <section>
      <title>Enumerations</title>

      <para>An enumeration defines a datatype which can be used as the type of
      an attibute of a business class. The enumeration definition includes a
      list of all enumeration values. The example below shown an enumeration
      definition.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve">"The severity level of a customer problem"
<keycap>Enumeration</keycap> SeverityLevel [
    Low    = 1;
    Middle = 2;
    High   = 3;
]
</programlisting>

      <para>The "= 1" ets defines the numeric value that is used for the
      enumeration literal in the code and the database. This is optional, but
      useful when you need to address existing encoding schemes for
      enumerations.</para>

      <section>
        <title>Generated code</title>

        <para>To Be Done</para>
      </section>
    </section>

    <section>
      <title>Business Rules</title>

      <para>A business class may include business rules. Note that the
      conceopt of business rule here is limited. In this context a business
      rule is a rule that should be true at all times for every object of the
      given business class.</para>

      <para>Other rules, for example one that trigger something when a certain
      condition is met, are not covered.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>Class</keycap> SampleClass [
    // properties go here ...
    // rules go here ...
    <keycap>Rules</keycap> [
        "A first rule"
        mustBeValid;
        "A second rule"
        isOriginal;
        "a unique rule"
        <keycap>unique</keycap> namesUnique [ firstname lastname ]
    ]
]
</programlisting>

      <para>There are two types of businessrules that can be modeled.</para>

      <para>The first type of businessrule has a name only in the model. The
      actual implementation of the rule must be written in Java as an
      extension to the generated code.</para>

      <para>The second type of rule is a uniqueness rule, which is indicated
      by the <emphasis>unique</emphasis> keyword. A uniquess rule specifies
      that the combination of values of one or more attributes of the class
      must be unique at all times. The names of the attributes are specified
      between brackets after the name of the rule.</para>

      <section>
        <title>Generated code</title>

        <para>For a business rule an abstract method with the name of the rule
        returning a boolean value is generated in the base class. This ensures
        that the developer must provide an implementation in the empty
        subclass.</para>

        <para>The first time the empty subclass is generated an empty method
        implementing the abstract method from the base class is genarted. This
        method returns true and contains a <emphasis>TODO comment</emphasis>
        to remind the developer he needs to implement the rule.</para>

        <para>The handling of the rules is completely generated. This means
        that the rule will be called and validated whenever the object
        changes. If the rule is broken, a BusinessClassException is created
        and thrown. Developers do not need to handle these errors
        themselves.</para>

        <para>See the empty-subclass pattern on how this is done in the
        code</para>
      </section>
    </section>

    <section>
      <title>Associations</title>

      <para>The final part of a domain model defines all the relationship,s
      beteenm the bsuiness classes.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>Association</keycap> customer Customer [0..1] &lt;-&gt; [0..*] orders     Order    ;
<keycap>Association</keycap> order    Order    [0..1]  -&gt; [0..*] orderLines OrderLine;
</programlisting>

      <para>This example shows one bidirectional association, which uses the
      &lt;-&gt; syntax and one unidirectional association using the -&gt;
      syntax.</para>

      <para></para>

      <section>
        <title>Generated code</title>

        <para>Associations are a powerful mechanism and require careful
        handling in the code. For bidirectional associations the generated
        code ensures that both sides will always be updates consistently
        whenever one of the sides is changed.</para>

        <section>
          <title>Generated Code for the Domain Layer</title>

          <para>On the domain layer the code is generated in the Java base
          class to store the references to objects at the opposite side of an
          association. For associations with multiplicito 0 or 1 this will be
          a field of the type at the oppoe side, for associoations with
          multiplicity greater than 1 this will be a field of typoe
          Set&lt;oppostite type&gt;.</para>

          <para>Next to these fields methods are generated to change these
          fields. For a single valued field a simple setter and getter is
          generated.</para>

          <para>For multivalues fields adding or deleting elements from the
          collection should always be done by the object owinng the
          collection. We cannot simply generate getter and setter nethods,
          because chnages in the collection can be done without the object
          knowing it, and the oibject cannot guarabntee consistentcy with the
          opposite objects.</para>

          <para>To resolev this problem we generate methods áddTo...',
          'removeFrom...' for the collection in the owning class. Fpor the
          Customer class in the above example we generate the áddToOrders()
          and removefromOrders() methods. The getter methoids returns an
          Unmodifyable collection to guard the clinet from changing the
          collection.</para>

          <para><programlisting class="monospaced" continuation="continues"
          format="specific" linenumbering="numbered" xml:space="preserve"><keycap>public abstract class </keycap>CustomerImplBase {
  /**
   *  orders: One 2 Many Bidirectional: The customer has a number of orders
   */
  <keycap>private </keycap>Set&lt;Order&gt; orders = <keycap>new</keycap> HashSet&lt;Order&gt;();

  /**
   * @return orders (Set&lt;Order&gt;) 
   */
  <keycap>public</keycap> Set&lt;Order&gt; getOrders()

  /**
   * Implements adding single element to a collection
   */
  <keycap>public void </keycap>addToOrders(Order element)

  /**
   * Implements removal of a single element from feature 
   * 
   * @param element 
   */
  <keycap>public void </keycap>removeFromOrders(Order element)
 <keycap /></programlisting>To support the consistency of the two sides of an
          association we always have to update the other side whenever
          something changes. We cannot simply call the other isded upodate
          methods, because they will call their opposite side in trun and we
          end up in an infinite loop.</para>

          <para>To solve this problem we use special that are only used to
          update the opposite side. All the methods als generated with
          'z_internal' as prefix. These methods are public because they must
          be callable from the opposite class. These methids should never be
          used for anything else.<programlisting class="monospaced"
          continuation="continues" format="specific" linenumbering="numbered"
          xml:space="preserve"><keycap>public abstract class </keycap>CustomerImplBase {
<keycap /><keycap /><keycap /><keycap /><keycap />
  /**
   * This operation should NOT be used by clients.  It implements the correct
   * addition of an element in an association.
   * 
   * @param element 
   */
  <keycap>public void </keycap>z_internalAddToorders(Order element) {

  /**
   * This operation should NOT be used by clients. It implements the correct
   * removal of an element in an association.
   * 
   * @param element 
   */
  <keycap>public void </keycap>z_internalRemoveFromorders(Order element)
<keycap /></programlisting></para>

          <para></para>

          <para></para>

          <para></para>
        </section>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Data Contrac DSL Reference</title>

    <para>This chapter provides a description of all the concepts in the Data
    Contract DSL. Each concept is described by a definition which explains the
    meaning of the concept, and a description of the code generated for the
    concept.</para>

    <section>
      <title>Data Transfer Object (DTO)</title>

      <para>The central concept in the Data Contract DSL is the Data Transfer
      Object, or DTO. A DTO is a value object that carries data only. The
      purpose of a DTO is to be able to send data to back and forth to and
      from clients.</para>

      <para>Clients communicatie with domain objects thriough servicves. The
      services and the service methods are defined by using the Service DSL.
      The DTO objects define the in- and out parameters for the service
      methods.</para>

      <para>There are several types of DTOs. A customDto is a DTO that may
      have any attributes. A BusinbessClassDto represents the data of a domain
      object as defined in the Business Domain DSL. A ListDto defines a
      collection of other DTOs. All these variants are described in detail
      below.</para>
    </section>

    <section>
      <title>CustomDto</title>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>CustomDto</keycap> ExampleDto [
    // properties go here ...
]
</programlisting>

      <para>A Business Class describes something that has a specific meaning
      in the buiness domain being modeled. In the system being modeled
      instances of business classes will be created.</para>

      <para>A business class has properties (also called attributes in e.g.
      UML) of diferent types.</para>

      <para>A busines class also contains business rules, that specify the
      conditions that an instance of the class needs to conform to.</para>

      <section>
        <title>Generated code</title>

        <para>For a business class code is generated for both the domain and
        the data layer of the architecture.</para>

        <section>
          <title>Domain Layer</title>

          <para>The second class generated is an empty (except for
          constructors calling <code>super()</code>) class which subclasses
          the first class. This empty class is what we call an
          <emphasis>extension point </emphasis>file, where manual code may be
          added. This extension class is generated once and not overwritten,
          which ensures that all handwritten code is maintained at all
          times.</para>
        </section>

        <section>
          <title>Data Layer</title>

          <para>In the datalayer a number of files is generated.</para>

          <para>A hibernate mapping file is generated for each
          businessclass.</para>

          <para>One Hibernate confiuguration file (how do you call this
          DatalaagContext.xml file) file is generated for the application as a
          whole.</para>
        </section>
      </section>
    </section>

    <section>
      <title>DTO Attributes</title>

      <section>
        <title>Definition</title>

        <para>DTO Attributes are part of a DTO and defined within the scope of
        their DTO. The example custom DTO personDto looks as follows.</para>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve"><keycap>CustomDto</keycap> ExampleDto [
    <keycap>string</keycap>   description; 
    <keycap>integer</keycap>  amount;    
    <keycap>datetime</keycap> deliverydate;       
    <keycap>decimal</keycap>  price;          
    "Description of the isOk attribute"
    <keycap>boolean</keycap>  isOk;          
]
</programlisting>

        <para>An attribute describes a field of a data transfer object.
        Attributes always have a defined type, which can be
        <emphasis>integer</emphasis>, <emphasis>string</emphasis>,
        <emphasis>decimal</emphasis>, <emphasis>boolean</emphasis> or
        <emphasis>datetime</emphasis>.</para>

        <para>Each attribute may have a description, which is placed directly
        before the attribute definition within double quotes. In the example
        only <emphasis>isOk</emphasis> has a description.</para>

        <para>Contrary to business classes in the Business Domain DSL,
        attributes of a DTO have no constraints associated with it.</para>
      </section>

      <section>
        <title>Generated code</title>

        <para>For an attribute code is generated for both the service layer of
        the architecture.</para>

        <para>For each DTO a Java class is generated. This class contains a
        protected field for each attribute and getter and setter methods to
        access the field.</para>

        <para>The fields in data transfer objets are always nullable,
        therefore the field types in the generated code are always real
        objkects. This means that <emphasis>Integer</emphasis>,
        <emphasis>Float</emphasis>, <emphasis>Boolean</emphasis> are used as
        field types for the attributes of type <emphasis>integer</emphasis>,
        <emphasis>decimal</emphasis> and <emphasis>boolean</emphasis>.</para>

        <para>The description of an attribute is used to generate Javadoc
        comments in the code for the attribute.</para>
      </section>
    </section>

    <section>
      <title>BusinessClassDto</title>

      <para>A BusinessClassDto is a DTO that represents the data of a business
      class from the Business Domain DSL. As a consequence, the attributes
      that are allowed within a BusinessClassDTO must map 1-to-1 to attributes
      of the corresponding business class.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>from</keycap> RecordShopDomainModel <keycap>import </keycap>Customer

<keycap>BusinessClassDto</keycap> SimpleCustomerDto <keycap>base </keycap>Customer [
    // attributes go here 
]
</programlisting>

      <para>A BusinessClassDto always declares the business class that it
      represents as its base class. This business class must be defined in a
      Business Domain model. To ensure that the business class is in scope it
      must be imported first from its business domain model. Import statements
      are always at the top of a data contract model.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>BusinessClassDto</keycap> SimpleCustomerDto <keycap>base </keycap>Customer [
    name; 
    numberOfEars;    
    birthdate;       
    length;          
    "Description of the isMale attribute"
    isMale;
]
</programlisting>

      <para>Attributes of a BusinessClassDto must have the same names as
      attributes in the bas business class. Not every attribute has to be
      thre, allowing a BusinessClassDto to contain a subset of attributes from
      its base business class.</para>

      <para>The type of the attributes is derived from the type iof the
      corresponding ttribute in the business class in the business domain
      model. Therefore it is not speciified in the data contract model.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>BusinessClassDto</keycap> SimpleCustomerDto <keycap>base </keycap>Customer [
    // attributes go here 

    <keycap>references </keycap>[ 
        orders <keycap>as</keycap> OrderNumberAndDateList ;  
    ]   
]
</programlisting>

      <para>A business class may take part is associations as defined in the
      business domain model. A BusinessClassdto may represent such an
      association as well. Tghere are restrictions on represented
      associations. The main restriction is only one side of an association is
      represented as a reference.</para>

      <para>The references are contained in the references block. The same
      rule that app;lied to attributes also applies to associations. Only
      associations thart are defined in the business domain model may be used.
      The name to be used is the role name of the opposite class in the
      association definition.</para>

      <para>The type mof a reference</para>

      <section>
        <title>Generated code</title>

        <para>For a business rule an abstract method with the name of the rule
        returning a boolean value is generated in the base class. This ensures
        that the developer must provide an implementation in the empty
        subclass.</para>

        <para>The first time the empty subclass is generated an empty method
        implementing the abstract method from the base class is genarted. This
        method returns true and contains a <emphasis>TODO comment</emphasis>
        to remind the developer he needs to implement the rule.</para>

        <para>The handling of the rules is completely generated. This means
        that the rule will be called and validated whenever the object
        changes. If the rule is broken, a BusinessClassException is created
        and thrown. Developers do not need to handle these errors
        themselves.</para>

        <para>See the empty-subclass pattern on how this is done in the
        code</para>
      </section>
    </section>

    <section>
      <title>ListDto</title>

      <para>The final part of a domain model defines all the relationship,s
      beteenm the bsuiness classes.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>Association</keycap> customer Customer [0..1] &lt;-&gt; [0..*] orders     Order    ;
<keycap>Association</keycap> order    Order    [0..1]  -&gt; [0..*] orderLines OrderLine;
</programlisting>

      <para>This example shows one bidirectional association, which uses the
      &lt;-&gt; syntax and one unidirectional association using the -&gt;
      syntax.</para>

      <para></para>

      <section>
        <title>Generated code</title>

        <para>Associations are a powerful mechanism and require careful
        handling in the code. For bidirectional associations the generated
        code ensures that both sides will always be updates consistently
        whenever one of the sides is changed.</para>

        <section>
          <title>Generated Code for the Domain Layer</title>

          <para>On the domain layer the code is generated in the Java base
          class to store the references to objects at the opposite side of an
          association. For associations with multiplicito 0 or 1 this will be
          a field of the type at the oppoe side, for associoations with
          multiplicity greater than 1 this will be a field of typoe
          Set&lt;oppostite type&gt;.</para>

          <para>Next to these fields methods are generated to change these
          fields. For a single valued field a simple setter and getter is
          generated.</para>

          <para>For multivalues fields adding or deleting elements from the
          collection should always be done by the object owinng the
          collection. We cannot simply generate getter and setter nethods,
          because chnages in the collection can be done without the object
          knowing it, and the oibject cannot guarabntee consistentcy with the
          opposite objects.</para>

          <para>To resolev this problem we generate methods áddTo...',
          'removeFrom...' for the collection in the owning class. Fpor the
          Customer class in the above example we generate the áddToOrders()
          and removefromOrders() methods. The getter methoids returns an
          Unmodifyable collection to guard the clinet from changing the
          collection.</para>

          <para><programlisting class="monospaced" continuation="continues"
          format="specific" linenumbering="numbered" xml:space="preserve"><keycap>public abstract class </keycap>CustomerImplBase {
  /**
   *  orders: One 2 Many Bidirectional: The customer has a number of orders
   */
  <keycap>private </keycap>Set&lt;Order&gt; orders = <keycap>new</keycap> HashSet&lt;Order&gt;();

  /**
   * @return orders (Set&lt;Order&gt;) 
   */
  <keycap>public</keycap> Set&lt;Order&gt; getOrders()

  /**
   * Implements adding single element to a collection
   */
  <keycap>public void </keycap>addToOrders(Order element)

  /**
   * Implements removal of a single element from feature 
   * 
   * @param element 
   */
  <keycap>public void </keycap>removeFromOrders(Order element)
 <keycap /></programlisting>To support the consistency of the two sides of an
          association we always have to update the other side whenever
          something changes. We cannot simply call the other isded upodate
          methods, because they will call their opposite side in trun and we
          end up in an infinite loop.</para>

          <para>To solve this problem we use special that are only used to
          update the opposite side. All the methods als generated with
          'z_internal' as prefix. These methods are public because they must
          be callable from the opposite class. These methids should never be
          used for anything else.<programlisting class="monospaced"
          continuation="continues" format="specific" linenumbering="numbered"
          xml:space="preserve"><keycap>public abstract class </keycap>CustomerImplBase {
<keycap /><keycap /><keycap /><keycap /><keycap />
  /**
   * This operation should NOT be used by clients.  It implements the correct
   * addition of an element in an association.
   * 
   * @param element 
   */
  <keycap>public void </keycap>z_internalAddToorders(Order element) {

  /**
   * This operation should NOT be used by clients. It implements the correct
   * removal of an element in an association.
   * 
   * @param element 
   */
  <keycap>public void </keycap>z_internalRemoveFromorders(Order element)
<keycap /></programlisting></para>

          <para></para>

          <para></para>

          <para></para>
        </section>
      </section>
    </section>

    <section>
      <title>EnumerationDto</title>

      <para>An enumeration defines a datatype which can be used as the type of
      an attibute of a business class. The enumeration definition includes a
      list of all enumeration values. The example below shown an enumeration
      definition.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve">"The severity level of a customer problem"
<keycap>Enumeration</keycap> SeverityLevel [
    Low    = 1;
    Middle = 2;
    High   = 3;
]
</programlisting>

      <para>The "= 1" ets defines the numeric value that is used for the
      enumeration literal in the code and the database. This is optional, but
      useful when you need to address existing encoding schemes for
      enumerations.</para>

      <section>
        <title>Generated code</title>

        <para>To Be Done</para>
      </section>
    </section>
  </chapter>
</book>