<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<part id="business-domain-dsl">
  <title>Business Domain DSL</title>

  <chapter>
    <title>Introduction</title>

    <section>
      <title>Purpose</title>

      <para>The Business Domain DSL is intended to be use for modeling the
      domain model of an application. De Busines Domain model consists of all
      domain classes, as understood by the business expert. Technical aspects
      do not belong in Business Domain models.</para>

      <para>From a business domain model code is generated, conforming to the
      reference architecture as describe in REF. As a consequence, the code
      will alsways conform perfectly to the architecture, ensuring a high
      quality application.</para>

      <para>This document describes the concepts as they are defined in the
      language and how they can be used to specify a business domain
      model.</para>
    </section>

    <section>
      <title>Principles</title>

      <para>The principles behind the mod4j project are important to
      understand how the DSL's are designed and how they should be
      used.</para>

      <itemizedlist>
        <listitem>
          <para>The goal of a model is to generate code. Thus, everything in a
          model is used in some way to generate code.</para>
        </listitem>

        <listitem>
          <para>Model and code live side by side. That is, we do not focus on
          100 percent code generation. Instead we focus on modeling aspects
          from which much code can be genmerated, while coding aspects that
          are as much work in codee as it is in a model. Given the time
          constraint6s that we all have, we start with the modeling concepts
          that give the best ratio of model-to-code.</para>
        </listitem>

        <listitem>
          <para>Generated code is never overwritten. Within the generated code
          specific extension point are generated. These extension points are
          the only places where handwritten code may be placed. In most cases
          an extension point is in a separete file than the generatee code. To
          help the developer a first empty extension point file is usually
          created , but only when the expension point file does not
          exist.</para>
        </listitem>

        <listitem>
          <para>DSL"s and DSL models are independent of each other. They may
          referen through soft references, but are never hard-linked to each
          other. Thids allows both DSL models and DSLs to be developed
          separately. It also allows version management by common tools as CVS
          or subversion.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Reference</title>

    <para></para>

    <section>
      <title>Business Class</title>

      <section>
        <title>Definition</title>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve"><keycap>Class</keycap> Person [
    // properties go here ...
    // rules go here ...
]
</programlisting>

        <para>A Business Class describes something that has a specific meaning
        in the buiness domain being modeled. In the system being modeled
        instances of business classes will be created.</para>

        <para>A business class has properties (also called attributes in e.g.
        UML) of diferent types.</para>

        <para>A busines class also contains business rules, that specify the
        conditions that an instance of the class needs to conform to.</para>
      </section>

      <section>
        <title>Generated code</title>

        <para>For a business class code is generated for both the domain and
        the data layer of the architecture.</para>

        <section>
          <title>Domain Layer</title>

          <para>In the domain code is generated according to the Empty
          baseclass pattern (REF). For each businessclass two Java classes are
          generated. The first Java class is an abstract base class containing
          all generated code for the business class. All code generated for
          properties, associations and business rules are placed inside this
          class.</para>

          <para>The second class generated is an empty (except for
          constructors calling <code>super()</code>) class which subclasses
          the first class. This empty class is an extension point file, where
          manual code may be added. This extension class is generated once and
          not overwritten, which ensures that all handwritten code is
          maintained at all times.</para>
        </section>

        <section>
          <title>Data Layer</title>

          <para>In the datalayer a number of files is generated.</para>

          <para>A hibernate mapping file is generated for each
          businessclass.</para>

          <para>One Hibernate ???? (how do you call this DatalaagContext.xml
          file) file is generated for the application as a whole.</para>

          <para>A Dao (Data Acces layer) is generated. The dao normally
          consists of one interface and an implementing class. To get a clean
          separation of generated and handwritten code both of these use the
          empty subclass pattern. The result for the Person class in the
          example is shown in figure REF.</para>
        </section>
      </section>
    </section>

    <section>
      <title>Properties</title>

      <section>
        <title>Definition</title>

        <para>Properties look like this.</para>

        <programlisting class="monospaced" continuation="continues"
                        format="specific" linenumbering="numbered"
                        xml:space="preserve"><keycap>Class</keycap> Person [
    <keycap>string</keycap>   name;
    <keycap>integer</keycap>  numberOfEars;
    <keycap>datetime</keycap> birthdate;
    <keycap>decimal</keycap>  length;
    <keycap>boolean</keycap>  isMale;
    // rules go here ...
]
</programlisting>

        <para>A property descibes a characteristic of a business class.
        Properties always have a type. Each instance of a business class has
        its own values for each propertyA property can have a predefined type,
        which can be <emphasis>integer</emphasis>,
        <emphasis>string</emphasis>, <emphasis>decimal</emphasis>,
        <emphasis>boolean</emphasis> or <emphasis>datetime</emphasis>. For
        each type specific constraints can be specified. These constraints
        must always be true for any value of the property.</para>

        <glosslist>
          <glossentry>
            <glossterm>minlengt</glossterm>

            <glossdef>
              <para>Defines the minimal number of characters of this
              attribute's value.</para>
            </glossdef>
          </glossentry>

          <glossentry>
            <glossterm>maxlenght</glossterm>

            <glossdef>
              <para>Defined the maximum number of characters of this
              attribute's value.</para>
            </glossdef>
          </glossentry>
        </glosslist>
      </section>

      <section>
        <title>Generated code</title>

        <para>For a property code is generated for both the domain and the
        data layer of the architecture.</para>

        <para>In the domain code is generated according to the Empty baseclass
        pattern (REF). For each businessclass an abstract baes class is
        generated. This code contains a field for the property and getter and
        setter methods. If the there are constaints speciified for the
        property in the model, validators for the proprty are also generated.
        Code is also generated to automatically call the validator whenever
        the value fo the property has changed, e.g. when calling the setter
        method.</para>

        <para>An empty subclass is also generated as an extension point for
        handwritten code.</para>

        <section>
          <title>String Attribute</title>

          <para>A string attribute is completely denoted as shown below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>string</keycap> name
      <keycap>default</keycap> "the default name"
      <keycap>minlength</keycap> 3 
      <keycap>maxlength</keycap> 10 
      <keycap>regexp</keycap> "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$"
      <keycap>nullable</keycap> ;

</programlisting>

          <para>Each attribute can have a description, which is places
          directly before the attribute definition. Each string attribute has
          a number of optional properties, as shown above. The order of the
          properties is fexed as shown. These properties act as constraints on
          the value of the attribute and are explained below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of thsi attribute. This value
                is assigned when the object is being created. The value may
                change later on in the Objects lifetime.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>minlengt</glossterm>

              <glossdef>
                <para>Defines the minimal number of characters of this
                attribute's value.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>maxlenght</glossterm>

              <glossdef>
                <para>Defined the maximum number of characters of this
                attribute's value.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>regexp</glossterm>

              <glossdef>
                <para>Defines the format of the attribute's value through a
                regular expression. The syntax of the reguar expression is
                defined by REF.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value..</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>

        <section>
          <title>Boolean Attribute</title>

          <para>A boolean attribute is completely denoted as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>boolean</keycap> fixed
      <keycap>default</keycap> "true"
      <keycap>nullable</keycap> ;

</programlisting>

          <para>Each attribute can have a description, which is places
          directly before the attribute definition. Each boolean attribute has
          a number of optional properties, as shown above. The order of the
          properties is fixed. These properties act as constraints on the
          value of the attribute and are explained below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute. This value
                is assigned when the object is being created. The value may
                change later on in the Objects lifetime.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>

        <section>
          <title>Integer Attribute</title>

          <para>An integer attribute is completely defined as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>integer </keycap>numberOfSteps
      <keycap>default</keycap> 12
      <keycap>min</keycap> 4
      <keycap>max</keycap> 32
      <keycap>nullable</keycap> ;

</programlisting>

          <para>A integer attribute has a number of optional properties, as
          shown above. The order of the properties is fixed. These properties
          act as constraints on the value of the attribute and are explained
          below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute. This value
                is assigned when the object is being created. The value may
                change later on in the Objects lifetime.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>min</glossterm>

              <glossdef>
                <para>Defines the minimal value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>max</glossterm>

              <glossdef>
                <para>Defines the maximum value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>

        <section>
          <title>Decimal Attribute</title>

          <para>An decimal attribute is completely defined as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>decimal</keycap> percentage
      <keycap>default</keycap> 12
      <keycap>min</keycap> 4
      <keycap>max</keycap> 32
      <keycap>nullable</keycap> ;

</programlisting>

          <para>A decimal attribute has a number of optional properties, as
          shown above. The order of the properties is fixed. These properties
          act as constraints on the value of the attribute and are explained
          below..</para>

          <glosslist>
            <glossentry>
              <glossterm>defauilt</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute. This value
                is assigned when the object is being created. The value may
                change later on in the Objects lifetime.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>min</glossterm>

              <glossdef>
                <para>Defines the minimal value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>max</glossterm>

              <glossdef>
                <para>Defines the maximum value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>

        <section>
          <title>Datetime Attribute</title>

          <para>An datetime attribute is completely defined as shown
          below</para>

          <programlisting class="monospaced" continuation="continues"
                          format="specific" linenumbering="numbered"
                          xml:space="preserve">"A readable description of this attribute"
<keycap>datetime day</keycap> started
    <keycap>  <keycap>default</keycap></keycap> 4
      <keycap>nullable</keycap> ;

</programlisting>

          <para>A datetime attribute has a number of optional properties, as
          shown above. The order of the properties is fixed. These properties
          act as constraints on the value of the attribute and are explained
          below..</para>

          <glosslist>
            <glossentry>
              <glossterm>accuray</glossterm>

              <glossdef>
                <para>Defines the accuracy of the datetime attribute. The
                possible values are year, month, day, hour, minute, second,
                millisecond. In the above example the accuracy is defined as
                day.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>default</glossterm>

              <glossdef>
                <para>Defines the default value of this attribute.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>nullable</glossterm>

              <glossdef>
                <para>The nullable property specifies that this attribute does
                not have to have a value. If nullable is no specified, the
                attribute must always have a defined value.</para>
              </glossdef>
            </glossentry>
          </glosslist>
        </section>
      </section>
    </section>

    <section>
      <title>Enumerations</title>

      <para>An enumeration defines a datatype which can be used as the type of
      an attibute of a business class. The enumeration definition includes a
      list of all enumeration values. The example below shown an enumeration
      definition.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve">"The severity level of a customer problem"
<keycap>Enumeration</keycap> SeverityLevel [
    Low    = 1;
    Middle = 2;
    High   = 3;
]
</programlisting>

      <para>The "= 1" ets defines the numeric value that is used for the
      enumeration literal in the code and the database. This is optional, but
      useful when you need to address existing encoding schemes for
      enumerations.</para>
    </section>

    <section>
      <title>Business Rules</title>

      <para>A business class may include business rules. Note that the
      conceopt of business rule here is limited. In this context a business
      rule is a rule that should be true at all times for every object of the
      given business class.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>Class</keycap> SampleClass [
    // properties go here ...
    // rules go here ...
    <keycap>Rules</keycap> [
        "A first rule
        mustBeValid;
        "A second rule"
        isOriginal;
    ]
]
</programlisting>

      <para>A rule only has a name in the model. The actual implementation of
      the rule must be written in Java as an extension to the generated
      code.</para>

      <para>The handling of the rule is completely generated. This means that
      the rule will be called and validated whenever the object changes. If
      the rule is broken, a BusinessClassException is created.</para>
    </section>

    <section>
      <title>Associations</title>

      <para>The final part of a domain model defines all the relationship,s
      beteenm the bsuiness classes.</para>

      <programlisting class="monospaced" continuation="continues"
                      format="specific" linenumbering="numbered"
                      xml:space="preserve"><keycap>Association</keycap> customer Customer [0..1] &lt;-&gt; [0..*] orders     Order    ;
<keycap>Association</keycap> order    Order    [0..1]  -&gt; [0..*] orderLines OrderLine;
</programlisting>

      <para>This example shows</para>
    </section>
  </chapter>
</part>