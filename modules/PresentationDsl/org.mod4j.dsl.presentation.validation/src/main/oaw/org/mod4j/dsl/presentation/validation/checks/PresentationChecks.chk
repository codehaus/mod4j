/*******************************************************************************
 * Copyright (c) 2008 Ordina and committers to Mod4j
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Ordina - initial implementation
 *******************************************************************************/
import PresentationDsl;
import crossx;
import ecore;

extension org::mod4j::dslcommon::xtend::generatorutil;
extension org::mod4j::dsl::presentation::mm::helpers::PresentationHelpers;
extension org::eclipse::xtend::util::stdlib::elementprops;
extension org::mod4j::crossx::broker::xtend::Crossx;
extension org::mod4j::dslcommon::xtend::ProjectProperties;

boolean hasDouble(Process process, ProcessType type ):
    (
       process.contentForm.actions.forAll(a | (a != process) implies ( a.type != type) ) 
    ) &&
    process.contentForm.processes.referredProcess.select(p | ! p.collectionContext).forAll(p | p.type != type  ) ;
  
boolean hasDouble(ProcessCall pcall, ProcessType ptype) :
    let process = pcall.referredProcess :
    ( 
        (
            (! process.collectionContext) implies
                  ((ContentForm)(pcall.owningDialogue)).actions.forAll(a | a.type != ptype)  
        ) &&
       pcall.owningDialogue.processes.referredProcess.remove(process).
            forAll(p | ( p.type == ptype) implies (p.collectionContext != process.collectionContext) ) 
     )
     ;

  
context CollectionDialogue ERROR this.name + " must havce exactly one dialogue of type content form" :
    (this.dialogues.size == 1) 
    &&
    (this.dialogues.first().referredContentForm() != null)
    &&
    (this.dialogues.first().referredContentForm().contextRef == this.contextRef) 
    ;

context Process if this.type == ProcessType::ADDTO
ERROR "An addto process must have exactly one form" :
    (this.processElements.size == 1) &&
    (this.processElements.typeSelect(DialogueCall).size == 1);

context Process if this.type == ProcessType::LINK
    ERROR "A link process must have exactly one form" :
    (this.processElements.size == 1) &&
    (this.processElements.typeSelect(DialogueCall).size == 1);

context Process ERROR "A save action / process cannot have a form attached to it" :
    (this.type == ProcessType::SAVE) implies (this.processElements.typeSelect(DialogueCall).isEmpty) ;
    
context Process ERROR "A delete action / process cannot have a form attached to it" :
    (this.type == ProcessType::DELETE) implies (this.processElements.typeSelect(DialogueCall).isEmpty) ;

context Process ERROR "A removefrom action / process cannot have a form attached to it" :
    (this.type == ProcessType::REMOVEFROM) implies (this.processElements.typeSelect(DialogueCall).isEmpty) ;
   
context Process if (this.type != ProcessType::CUSTOM) && (this.contentForm != null) 
    ERROR "11 A Content Form may have at most one '" + this.type + "' action or process" :
    hasDouble(this, this.type);
    
context Process if this.type == ProcessType::SAVE 
    ERROR "A 'save' process cannot have a 'list'  context ":
    ! this.collectionContext;

context Process if this.type == ProcessType::EDIT 
    ERROR "An 'edit' process cannot have a 'list'  context ":
    ! this.collectionContext;

/* INCORRECT FOR EXTERNAL PROCESSCALL
context ProcessCall if (this.referredProcess.type != ProcessType::CUSTOM) && (this.owningDialogue != null) 
    ERROR "12 A Content Form may have at most one " + this.referredProcess.type + "' action or process" :
    hasDouble(this, this.referredProcess.type);
*/

context Process 
    ERROR "Process error " + this.getProperty("ERROR") :
    let result = checkProcess(this) :       
    (result.startsWith("ERROR:") ? ( this.setProperty("ERROR", result)->false ): true )
     ;

context ProcessCall if referredProcess != null
    ERROR "ProcessCall error " + this.getProperty("ERROR") :
    let result = checkProcessCall(this) :       
    (result.startsWith("ERROR:") ? ( this.setProperty("ERROR", result)->false ): true )
      ;

context ProcessCall if (this.owningDialogue != null) && (referredProcess.name != null) && (this.referredProcess.metaType != ProcessReference)
                       && (this.owningDialogue.contextRef.name != null)
    ERROR "The process [" + this.referredProcess.name + "] must have the same context as the from to which it belongs [" + this.owningDialogue.name + "]" :
    this.owningDialogue.contextRef.name.equalsIgnoreCase(this.referredProcess.contextRef.name);

context UICall if this.contextExp.metaType == StandardExpression
    ERROR "No servce method found for [" + this.referredUIModelElement().contextRef.name + "] of type 'listall', needed to support the use of 'all'" :
    let con = this.referredUIModelElement().contextRef :
    findServiceMethod(this, con.name, "LISTALL") != null;
    
context UICall if this.contextExp.metaType == StandardExpression
    ERROR "No servce method found for [" + this.referredUIModelElement().contextRef.name + "] of type 'find', needed to support the use of 'all'" :
    let con = this.referredUIModelElement().contextRef :
    findServiceMethod(this, con.name, "FIND") != null;
    
String findSpecialMethod(String dtoName, String methodType) :
    let methods = 
    findAllSymbols(getProject(), "Service").first().findAllSubSymbols("ServiceMethod").
    select( method | method.getPropertyValue("methodType").endsWith(methodType) && method.getPropertyValue("dto").endsWith(dtoName)) :
    (methods.isEmpty ? null : methods.first().name);
    
String findSpecialMethodInService(String dtoName, String methodType, Symbol service) :
    service.findAllSubSymbols("ServiceMethod").
    select( method | method.getPropertyValue("methodType").endsWith(methodType) && method.getPropertyValue("dto").endsWith(dtoName)).first().name;
    
// returns the name of a service that contains a special method of "methodType" for the referred DTO in "form"
String findServiceWithMethod(String dtoName, String methodType) :
    findAllSymbols(getProject(), "Service").select( s | findSpecialMethodInService(dtoName, methodType, s) != null ).first().name;

// returns the symbol of the special method of "methodType" for the referred DTO 
// TODO: should only look in the current project, but this p[roject cannot be found
Symbol findServiceMethod(UICall self, String dtoName, String methodType) :
//    findAllSymbols(getProjectForEObject(self), "Service").select( s | findSpecialMethodInService(dtoName, methodType, s) != null ).first();
    findAllModels().modelname.findAllFromModel("Service").select( s | findSpecialMethodInService(dtoName, methodType, s) != null ).first();

Symbol findMethodInService(Symbol service, String methodName) :
    service.findAllSubSymbols("ServiceMethod").
    selectFirst( method | method.name == methodName);
    
