«REM»
    Copyright (c) 2010 Ordina and committers to Mod4j
    All rights reserved. This program and the accompanying materials
    are made available under the terms of the Eclipse Public License v1.0
    which accompanies this distribution, and is available at
    http://www.eclipse.org/legal/epl-v10.html
     
    Contributors:
        Ordina - initial implementation
«ENDREM»
«IMPORT PresentationDsl»
«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dsl::presentation::mm::helpers::PresentationHelpers»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::dsl::presentation::generator::xtend::helpers»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx»


«DEFINE generateDataProvider FOR Action»
«EXPAND JavaComments::regenerationWarningHeader ("Mod4j PresentationDsl generator: DtoDataProvider.xpt") FOR this»
«LET this.nextPage.contextRef.name AS context»
«LET findServiceWithMethod(context, "LISTALL") AS listAllServiceType»
«LET findServiceWithMethod(context, "FIND") AS findServiceType»
«LET findSpecialMethodInService(context, "LISTALL", listAllServiceType) AS listAllService»
«LET findSpecialMethodInService(context, "FIND", findServiceType) AS findService»
«LET { listAllServiceType, findServiceType }.toSet() AS allServiceTypes»
«print("SET " + allServiceTypes)»
package «getPresentationRootPackage()».dataproviders;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;

import org.apache.wicket.extensions.markup.html.repeater.data.table.filter.IFilterStateLocator;
import org.apache.wicket.extensions.markup.html.repeater.util.SortParam;
import org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;
import org.apache.wicket.model.IModel;
import org.apache.wicket.model.LoadableDetachableModel;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import «getPresentationCommonPackage()».processes.ProcessType;
import «getPresentationServiceFacadeClassPath(this.findModel().name)»;

import «javaDtoClassPath(context)»;

/**
 * Advanced dataprovider that takes care of getting sortable pages of object-lists
 * from a service.
 */
@SuppressWarnings("serial")
public class  «getWicketDataProviderClass(context)» extends SortableDataProvider<«context»> implements
        IFilterStateLocator, Mod4jDataProvider<«context»> {

    private static final Log log = LogFactory.getLog(«getWicketDataProviderClass(context)».class);

    /** Store filter information */
    private «context» filter;
    
    static protected Collection<ProcessType> processTypes = Arrays.asList(
         ProcessType.CUSTOM, ProcessType.NEW, ProcessType.EDIT, ProcessType.DELETE, ProcessType.SAVE, ProcessType.CANCEL);

    public Collection<ProcessType> supportedProcesses() {
        return processTypes;
    }
    
    /**
     * Create a new DataProvider 
     */
    public «getWicketDataProviderClass(context)»() {
    }

    public Iterator<«context»> iterator(int first, int count) {

        SortParam sp = getSort();
        «REM» TODO: Its better to use the service names as specified by the user in the service model.
        «IF findService != null -»
        if (filter != null) {
            return «findServiceType»Service.«findService»(filter, first, count, sp.getProperty(), sp.isAscending()).iterator();
        }«ENDIF»
        return «listAllServiceType»Service.«listAllService»(first, count, sp.getProperty(), sp.isAscending()).iterator();
        «ENDREM»
        «IF findService != null -»
        if (filter != null) {
            return «getPresentationServiceFacadeClass()».find«context»(filter, first, count, sp.getProperty(), sp.isAscending()).iterator();
        }«ENDIF»
        return «getPresentationServiceFacadeClass()».list«context»(first, count, sp.getProperty(), sp.isAscending()).iterator();
    }

    public IModel<«context»> model(«context» object) {
        final Long id = (object).getId();
        return new LoadableDetachableModel<«context»>() {

            @Override
            protected «context» load() {
                return «getPresentationServiceFacadeClass()».read«context»(id);
            }
        };
    }

    public int size() {
        Long result;
        «IF findService != null -»
        if (filter != null) {
            result = «getPresentationServiceFacadeClass()».count«context»(filter);
        } else {«ENDIF»
            result = «getPresentationServiceFacadeClass()».count«context»();
        «IF findService != null -»}«ENDIF»    
        return result.intValue();
    }

    public Object getFilterState() {
        return filter;
    }

    public void setFilterState(Object state) {
        filter = («context») state;
    }
}
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDLET»
«ENDDEFINE»