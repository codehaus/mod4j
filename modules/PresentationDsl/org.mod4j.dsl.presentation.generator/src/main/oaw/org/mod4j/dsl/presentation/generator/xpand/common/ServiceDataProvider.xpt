«REM»
    Copyright (c) 2010 Ordina and committers to Mod4j
    All rights reserved. This program and the accompanying materials
    are made available under the terms of the Eclipse Public License v1.0
    which accompanies this distribution, and is available at
    http://www.eclipse.org/legal/epl-v10.html
     
    Contributors:
        Ordina - initial implementation
«ENDREM»
«IMPORT PresentationDsl»
«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dsl::presentation::generator::xtend::helpers»
«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::crossx::broker::xtend::Crossx»

«DEFINE GenerateDataProvider FOR PresentationModel -»
    «EXPAND JavaComments::regenerationWarningHeader ("Mod4j PresentationDsl generator: ServiceDataProvider.xpt") FOR this»
package «getPresentationRootPackage()».panels;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.wicket.markup.repeater.data.IDataProvider;
import org.apache.wicket.model.IModel;
import org.apache.wicket.model.CompoundPropertyModel;

/**
 * Dataprovider for service list which takes the list of objects from a service.
 * @author jwa11799
 *
 */
@SuppressWarnings("serial")
public class ServiceDataProvider<ServiceType, DtoType> implements IDataProvider<DtoType> {
	private static final Log log = LogFactory.getLog(ServiceDataProvider.class);

	private ServiceType service;

	/**
	 * Create a new ServiceDataProvider 
	 * @param service The service from which the list and count is retrieved.
	 */
	public ServiceDataProvider(ServiceType service, String listAllName, String countName) {
		this.service = service;
		this.listAllName = listAllName;
		this.countName = countName;
		countMethod = findCountMethod();
		listAllMethod = findListAllMethod();
	}
	
	private String listAllName = "UNKNOWN";
	private String countName   = "UNKNOWN";

	@SuppressWarnings("unchecked")
	synchronized public Iterator iterator(int first, int count) {

		Integer[] params = {first, count};

        List<DtoType> result = null;
		try {
			if( listAllMethod == null ) {
				throw new NullPointerException("ListAll null for [" + listAllName+ "] ");
			}
			result = (List<DtoType>) listAllMethod.invoke(service, params);
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return result.iterator();
	}

	public IModel<DtoType> model(DtoType object) {
		return new CompoundPropertyModel<DtoType>(object);
	}

	Method countMethod = null;
	Method listAllMethod = null;

	synchronized public int size() {
		
		Long result = null;
		Object[] params = {};
		try {
			if( service == null ){
				throw new NullPointerException("service is null");
			}
			if( countMethod == null ){
				throw new NullPointerException("CountMethod is still null");
			}
			result = (Long)  countMethod.invoke(service, params);
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IllegalArgumentException();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result.intValue();
	}

	private Method findCountMethod() {
		Class cls = service.getClass();
		Class[] countArgs = {};
		Method countMethod   = null;
		try {
			countMethod   = cls.getMethod(countName, countArgs);
			if( countMethod == null ) {
				throw new NullPointerException("Count null for [" + countName + "] in class [" + cls.getName() + "]");
			}
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
//			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return countMethod;
	}

	public void detach() {
	}
	
	private Method findListAllMethod() {
		Class cls = service.getClass();
		Class[] args = {int.class, int.class};
		Method listAllMethod = null;
		try {
			listAllMethod = cls.getMethod(listAllName, args);
			if( listAllMethod == null ) {
				throw new NullPointerException("ListAll null for [" + listAllName+ "] in class [" + cls.getName() + "]");
			}
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new NullPointerException("ListAll [" + listAllName+ "] SecurityException [" + e.getMessage() + "]");
		} catch (NoSuchMethodException e) {
	//		// TODO Auto-generated catch block
			e.printStackTrace();
			throw new NullPointerException("ListAll [" + listAllName+ "] NoSuchMethodException [" + e.getMessage() + "]");
		}
		return listAllMethod;
	}
}
«ENDDEFINE»