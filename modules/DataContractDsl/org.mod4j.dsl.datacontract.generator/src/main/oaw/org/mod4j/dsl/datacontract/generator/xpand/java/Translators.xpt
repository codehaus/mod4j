«REM»
      Copyright (c) 2009 Ordina and committers to Mod4j
      All rights reserved. This program and the accompanying materials
      are made available under the terms of the Eclipse Public License v1.0
      which accompanies this distribution, and is available at
      http://www.eclipse.org/legal/epl-v10.html
     
      Contributors:
          Ordina - initial implementation
«ENDREM»
«IMPORT DataContractDsl»
«IMPORT org::mod4j::dslcommon::xpand::java»

«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dsl::datacontract::generator::xtend::Dto»

«DEFINE createTranslator FOR Dto»
    «REM»No generation for this super type«ENDREM»
«ENDDEFINE»

«DEFINE createTranslator FOR BusinessClassDto»
        «EXPAND JavaComments::regenerationWarningHeader ("Mod4j DatacontractDsl generator: Translators.xpt") FOR this»

         package «getTranslatorsPackage()»;
         
         import java.util.HashMap;
         import java.util.Map;
         import java.util.HashSet;
         import java.util.Set;
         import org.mod4j.runtime.exception.ConcurrentUpdateException;
         import org.mod4j.runtime.exception.TranslatorException;
         import «getDomainRootPackage()».«javaClassName(base.name)»;
         import «getDomainRootPackage()».«javaClassName(base.name)»Example;
         import «getDtoPackage()».«javaClassName(name)»;
         «FOREACH properties.typeSelect(DtoAssociationRoleProperty) AS assRef -» 
             import «getDomainRootPackage()».«EXPAND getBaseDtoBaseName FOR assRef.dtoType -»;
             import «getDtoPackage()».«EXPAND getBaseDtoName FOR assRef.dtoType -»;
         «ENDFOREACH»
         
        /**
         * Translator for translating «javaClassName(base.name)» domain objects from- and to «javaClassName(name)» data transfer objects. 
         *
         * @author generated by Mod4j
         */
         public class «javaTranslatorName(javaClassName(name))» {
         
            /**
                * Thread-local register for translated «javaClassName(base.name)» objects
             */
             private static ThreadLocal<Map<Object, Object>> translatedHolder = new ThreadLocal<Map<Object, Object>>() {
             public Map<Object, Object> initialValue() {
                 return new HashMap<Object, Object>();
             }
         };

         private Map<Object, Object> getTranslated() {
             return translatedHolder.get();
         }

              «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                  «IF dataProperty.metaType == DtoEnumerationProperty -»
                      private «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator «dataProperty.name»Translator = new «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator();
                  «ENDIF»        
              «ENDFOREACH»
         
             /**
              «IF this.creatable»
              * Translates a «javaClassName(name)» dto object into a «javaClassName(base.name)» domain object.
              * A new domain object will be created passed to the {@link #fromDto(FullCustomerDto, Customer)}.
              «ELSE»
              * A TranslatorException is thrown, since this DTO does not contain all the mandatory properties of the referenced {@link «javaClassName(base.name)»}. 
              * Therefore, the DTO must always be based on an existing {@link «javaClassName(base.name)»}.
              «ENDIF».
              *
              * @param source The {@link «javaClassName(name)»} object to translate, may not be {@code null}.
              * @return {@link «javaClassName(base.name)»}, the resulting domain object.
              * @throws TranslatorException
              */
              public «javaClassName(base.name)» fromDto(final «javaClassName(name)» source) throws TranslatorException {
                  «REM»A DTO is NOT creatable if it does not contain all mandatory properties of the domain object. See CompleteDtc.ext. «ENDREM»
                  «IF this.creatable -»
                      if (getTranslated().containsKey((source))) {
                          return («javaClassName(base.name)») getTranslated().get(source);
                      }              

                      if (source == null ) {
                          throw new TranslatorException("Argument source is null! Translation of a domain object can not be based on a null object.");
                      }
              
                      if (source.getId() != null) {
                          throw new TranslatorException("Can not translate a dto with existing id to a new domain object. Dto: " + source.toString());
                      }

                      «FOREACH properties.select(e|e.mandatoryForCreation) AS nonNullableProp-»
                          if (source.«getterPrefix(nonNullableProp)»«javaClassName(nonNullableProp.name)»() == null) throw new TranslatorException("Can not translate dto to «javaClassName(base.name)» when non-nullable attribute «nonNullableProp.name» is null.");
                      «ENDFOREACH»
                   
                      «javaClassName(base.name) -» target = new «javaClassName(base.name) -»(«EXPAND Constructors::addConstructorArgumentsList -»);
                                    
                      return fromDto(source, target);
                  «ELSE -»
                      throw new TranslatorException("Translation of this source dto must be based on a existing domain object. Dto: " + source.toString());
                  «ENDIF»
              }         
                                     
             /**
              * Translates a «javaClassName(name)» dto object into a «javaClassName(base.name)» domain object. All properties in the dto will be mapped to the 
              * corresponding property in the <code>target</code> domain object. 
              *
              * @param source The {@link «javaClassName(name)»} object to translate, may not be {@code null}.
              * @param target The {@link «javaClassName(base.name)»} object translated from source, may not be {@code null}.
              * @return {@link «javaClassName(base.name)»}, the resulting domain object.
              * @throws TranslatorException
              */
              public «javaClassName(base.name)» fromDto(final «javaClassName(name)» source, final «javaClassName(base.name)» target) throws TranslatorException {

                  if (getTranslated().containsKey((source))) {
                      return («javaClassName(base.name)») getTranslated().get(source);
                  }
                 
                  if (source == null ) {
                      throw new TranslatorException("Argument source is null! Translation of a dto can not be based on a null dto.");
                  }

                  if (target == null) {
                      throw new TranslatorException("Argument target is null! Translation of a dto can not be based on a null domain object.");
                  }
                  
                  «FOREACH properties.select(e|e.mandatoryForCreation) AS nonNullableProp-»
                      if (source.«getterPrefix(nonNullableProp)»«javaClassName(nonNullableProp.name)»() == null) throw new TranslatorException("Can not translate dto to «javaClassName(base.name)» when non-nullable attribute «nonNullableProp.name» is null.");
                  «ENDFOREACH»

                  final boolean equals = (source.getId() == null) ? target.getId() == null
                                                                  : source.getId().equals(target.getId());

                  if (!equals) {
                      throw new TranslatorException("Can not translate a dto to a domain object when the id of the dto differs from the id of the domain object.");
                  }
                  
                  validateVersion(source, target);
                  
                  target.activateValidation(false);                 
                  
                  «FOREACH properties.typeSelect(DtoDataProperty).select(e|e.writable) AS dataProperty -»
                      «IF !dataProperty.nullable && !dataProperty.mandatoryForCreation»if (source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»() != null) {«ENDIF-»
                          «IF dataProperty.metaType == DtoEnumerationProperty -»
                              target.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.fromDto(source.get«javaClassName(dataProperty.name)»()));
                          «ELSE -»
                                  target.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                          «ENDIF -»
                      «IF !dataProperty.nullable && !dataProperty.mandatoryForCreation»}«ENDIF»
                  «ENDFOREACH»
              
                  «FOREACH properties.typeSelect(DtoAssociationRoleProperty) AS assRef -» 
                      «EXPAND getBaseDtoName FOR assRef.dtoType»Translator «assRef.name»Translator = new «EXPAND getBaseDtoName FOR assRef.dtoType»Translator();
                  «ENDFOREACH» 
                  getTranslated().put(source, target);
                  «FOREACH  associationReferences AS assRef -»
                  
                         /*
                          * Synchronize «assRef.name.toFirstUpper()» association.
                          */
   «REM»2Many«ENDREM» «IF assRef.dtoType.metaType == ListDto -»
   		                  Set<«EXPAND getBaseDtoBaseName FOR assRef.dtoType -»> toBeRemoved = new HashSet<«EXPAND getBaseDtoBaseName FOR assRef.dtoType -»>();
		                  /* Avoid changing the collection underneath an active iterator. */
		                  for («EXPAND getBaseDtoBaseName FOR assRef.dtoType -» element : target.get«assRef.name.toFirstUpper()»()) {
		                      if (source.getFrom«assRef.name.toFirstUpper()»(element.getId()) == null) {
		                          toBeRemoved.add(element);
		                      }
		                  }
		                  /* Objects to be removed */
		                  for («EXPAND getBaseDtoBaseName FOR assRef.dtoType -» element : toBeRemoved) {
		                      target.removeFrom«assRef.name.toFirstUpper()»(element);
		                  }
		                  for («EXPAND getBaseDtoName FOR assRef.dtoType -» element : source.get«assRef.name.toFirstUpper()»()) {
		                      if (element.getId() == null) {
		                          /* A new object to be added */
		                          target.addTo«assRef.name.toFirstUpper()»(«assRef.name»Translator.fromDto(element));
		                      } else {
		                          /* An existing object to be updated */
		                          «assRef.name»Translator.fromDto(element, target.getFrom«assRef.name.toFirstUpper()»(element.getId()));
		                      }
		                  }
   «REM»2One«ENDREM» «ELSE»
                         if (source.get«assRef.name.toFirstUpper()»() == null && target.get«assRef.name.toFirstUpper()»() != null) {
                             /* Delete associated object */
                             target.set«assRef.name.toFirstUpper()»(null);
                         } else if (source.get«assRef.name.toFirstUpper()»() != null && target.get«assRef.name.toFirstUpper()»() == null) {
                             /* Add a new associated object */
                             target.set«assRef.name.toFirstUpper()»(«assRef.name»Translator.fromDto(source.get«assRef.name.toFirstUpper()»()));
                         } else if (source.get«assRef.name.toFirstUpper()»() != null && target.get«assRef.name.toFirstUpper()»() != null) {
                             /* Update an existing associated object */
                             target.set«assRef.name.toFirstUpper()»(«assRef.name»Translator.fromDto(source.get«assRef.name.toFirstUpper()»(), target.get«assRef.name.toFirstUpper()»()));
                         }
                     «ENDIF»
                  «ENDFOREACH»
                  getTranslated().remove(source);
                  target.activateValidation(true);

                  return target;
              }
             
             /**
              * Translates a «javaClassName(base.name)» domain object into a «javaClassName(name)» dto object. Properties and associations of the domain object
              * will be mapped to the corresponding properties and associations in the dto object.
              * To prevent looping while translating biderectional or circulair associations translated objects will be added to the 'translated' register.    
              *
              * @param source The {@link «javaClassName(base.name)»} object to translate.
              *
              * @return «javaClassName(name)» The {@link «javaClassName(name)»} object translated from source.
              */
              public «javaClassName(name)» toDto(final «javaClassName(base.name)» source) {
                  if (getTranslated().containsKey((source))) {
                      return («javaClassName(name)») getTranslated().get(source);
                  }
                 
                  if (source == null ) {
                      throw new TranslatorException("Argument source is null! Translation of a domain object can not be based on a null object.");
                  }
                  
                  «javaClassName(name)» result = new «javaClassName(name)»(source.getId(), source.getVersion());
                  «FOREACH properties.typeSelect(DtoDataProperty).select(e|e.writable) AS dataProperty -»
                      «IF dataProperty.metaType == DtoEnumerationProperty -»
                          result.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.toDto(source.get«javaClassName(dataProperty.name)»()));
                      «ELSE -»
                          result.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                      «ENDIF -»
                  «ENDFOREACH»
              
                  «FOREACH properties.typeSelect(DtoAssociationRoleProperty) AS assRef -» 
                      «EXPAND getBaseDtoName FOR assRef.dtoType»Translator «assRef.name»Translator = new «EXPAND getBaseDtoName FOR assRef.dtoType»Translator();
                  «ENDFOREACH» 
                  getTranslated().put(source, result);
                  «FOREACH properties.typeSelect(DtoAssociationRoleProperty) AS assRef -»
                     «IF assRef.dtoType.metaType == ListDto -» «REM»2Many«ENDREM»                       
                           for («EXPAND getBaseDtoBaseName FOR assRef.dtoType -» element: source.get«assRef.name.toFirstUpper()»()) {
                              result.addTo«assRef.name.toFirstUpper()»(«assRef.name»Translator.toDto(element));
                          }
                     «ELSE -» «REM»2One«ENDREM»
                         if( source.get«assRef.name.toFirstUpper()»() != null ) {
                             result.set«assRef.name.toFirstUpper()»(«assRef.name»Translator.toDto(source.get«assRef.name.toFirstUpper()»()));
                         }
                     «ENDIF -»
                  «ENDFOREACH»
                  getTranslated().remove(source);

                  return result;
              }
              
              «EXPAND exampleFromDto FOR this»
          
          
          /**
		    * Validate that the version of the DTO and the business object are valid.
		    * The DTO may only have a version if the domain object also has a version.
		    * When they both have a version and the DTO version is less, another user
		    * has updated the domain object in the meantime, if it is equal, all is
		    * well. If it is more, an unexpected situation occurs: the DTOs is more new
		    * then the domain object: this is not possible.
		    * 
		    * @param source
		    *            The DTO.
		    * @param target
		    *            The domain object target.
		    */
		   private void validateVersion(final «javaClassName(name)» source, final «javaClassName(base.name)» target) {
		       final Integer sourceVersion = source.getVersion();
		       final Integer targetVersion = target.getVersion();

                       // FIXME the DTO translator should not know that -1 is the default unpersisted value!
                       final boolean equals = (sourceVersion == null) ? targetVersion == -1
                                                                      : sourceVersion.equals(targetVersion);

		       if (!equals) {
		           throw new ConcurrentUpdateException("Versions of source and target do not match for dto " + source + 
                                                         ", source is " + sourceVersion + 
                                                         ", target is " + targetVersion + ".");
		       }
		   }
           }
«ENDDEFINE»

«DEFINE exampleFromDto FOR BusinessClassDto»
«LET this.base.name.javaDomainExampleClass() AS ExampleClass»
«LET this.base.name.javaDomainClass() AS Class»

 /**
  * Translates a «javaClassName(name)» dto object into a «ExampleClass» Example domain object. 
  * All properties in the dto will be mapped to the corresponding property in the <code>target</code> domain object. 
  * Association references in the dto will not be translated into the <code>target</code> domain object.
  *
  * @param source The {@link «javaClassName(name)»} object to translate.
  *
  * @return {@link «ExampleClass»}, the resulting businessclass object.
  */
  public «ExampleClass» exampleFromDto(final «javaClassName(name)» source) throws TranslatorException {
        «ExampleClass» result = new «ExampleClass»();
     
      if (source == null ) {
          throw new TranslatorException("Argument source is null! Translation of a dto can not be based on a null dto.");
      }

      «FOREACH properties.typeSelect(DtoDataProperty).select(e|e.writable) AS dataProperty -»
              «IF dataProperty.metaType == DtoEnumerationProperty -»
                  if( source.get«javaClassName(dataProperty.name)»() != null ){
                      result.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.fromDto(source.get«javaClassName(dataProperty.name)»()));
                  }
              «ELSE -»
                  if( source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»() != null ){
                      result.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                  }
              «ENDIF -»
      «ENDFOREACH»
      return result;
  }
«ENDLET»
«ENDLET»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR ListDto -»
    «javaClassName(baseDto.name) -»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR BusinessClassDto -»
    «javaClassName(name) -»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR BusinessClassDto -»
    «javaClassName(base.name) -»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR ListDto -»
    «EXPAND getBaseDtoBaseName FOR baseDto -»
«ENDDEFINE»
