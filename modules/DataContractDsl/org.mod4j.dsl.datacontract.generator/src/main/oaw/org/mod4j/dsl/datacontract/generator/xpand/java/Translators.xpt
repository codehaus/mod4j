«IMPORT DataContractDsl»

«EXTENSION org::mod4j::dslcommon::xtend::generatorutil»
«EXTENSION org::mod4j::dslcommon::xtend::ProjectProperties»
«EXTENSION org::mod4j::common::xtend::FileTracker»
«EXTENSION org::mod4j::common::xtend::NameMapper»
«EXTENSION org::mod4j::dsl::datacontract::generator::xtend::Dto»

«DEFINE createTranslator FOR Dto»
    «REM»No generation for this super type«ENDREM»
«ENDDEFINE»

«DEFINE createTranslator FOR BusinessClassDto»
«REM»
    «FILE generate(javaPathFileName(getTranslatorsPackage(), javaTranslatorName(javaClassName(name))))»
«ENDREM»
	«FILE generate(getServiceModuleName(), javaPathFileName(javaTranslatorClassPath(name)))»
        /**
         * Generated by Mod4j DataContract DSL in Translators.xpt at: «timestamp()»
         */
         package «getTranslatorsPackage()»;
         
         import java.util.HashMap;
         import java.util.Map;
         import org.mod4j.runtime.exception.TranslatorException;
         import «getDomainRootPackage()».«javaClassName(base.name)»;
         import «getDtoPackage()».«javaClassName(name)»;
         «FOREACH properties.typeSelect(DtoEnumerationProperty) AS enumDto -»
             import «getDtoPackage()».«javaClassName(enumDto.type.name)»;
         «ENDFOREACH»
         «FOREACH associationReferences AS assRef -»    
             import «getDomainRootPackage()».«EXPAND getBaseDtoBaseName FOR assRef.dtoType -»;
         «ENDFOREACH»  
         
        /**
         * Translator for translating «javaClassName(base.name)» businessclass objects from- and to «javaClassName(name)» data transfer objects. 
         *
         * @author generated by Mod4j
         */
         public class «javaTranslatorName(javaClassName(name))» {
         
             /**
           	  * Register for translated «javaClassName(base.name)» objects
	          */
              private Map<«javaClassName(base.name)», «javaClassName(name)»> translated = new HashMap<«javaClassName(base.name)», «javaClassName(name)»>();
              
              «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                  «IF dataProperty.metaType == DtoEnumerationProperty -»
                      private «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator «dataProperty.name»Translator = «javaClassName(((DtoEnumerationProperty)dataProperty).type.name)»Translator.getInstance();
                  «ENDIF»        
              «ENDFOREACH»
                                     
              «EXPAND org::mod4j::dslcommon::xpand::java::Singleton::makeSingleton FOR javaTranslatorName(javaClassName(name)) -»
         
             /**
              * Translates a «javaClassName(name)» dto object into a «javaClassName(base.name)» businessclass object. All properties in the dto will be mapped to the 
              * corresponding property in the <code>target</code> businessclass. Association references in the dto 
              * wil not be translated into the <code>target</code> bussiness class.
              * If the given <code>target</code> parameter is null, a«IF this.creatable» new businessclass object will be created and returned«ELSE»TranslatorException is thrown«ENDIF».
              *
              * @param source The {@link «javaClassName(name)»} object to translate.
              * @param target The {@link «javaClassName(base.name)»} object translated from source.
              *
              * @return {@link «javaClassName(base.name)»}, the resulting businessclass object.
              * @throws TranslatorException
              */
              public synchronized «javaClassName(base.name)» fromDto(final «javaClassName(name)» source, «javaClassName(base.name)» target) throws TranslatorException {
                 
                  if (source == null ) {
                      throw new TranslatorException("Argument source is null! Translation of a dto can not be based on a null dto.");
                  }
                  
                  «FOREACH properties.select(e|e.mandatoryForCreation) AS nonNullableProp-»
                      if (source.get«javaClassName(nonNullableProp.name)»() == null) throw new TranslatorException("Can not translate dto to «javaClassName(base.name)» when non-nullable attribute «nonNullableProp.name» is null.");
                  «ENDFOREACH»
                                    
                  «IF this.creatable -»
                      if (target == null) {
                          if (source.getId() > 0) {
                              throw new TranslatorException("Can not translate a dto with existng id to a new businessclass object.");
                          }
                          target = new «javaClassName(base.name) -»(«EXPAND Constructors::addConstructorArgumentsList -»);
                      }
                  «ELSE -»
                      if (target == null ) {
                          throw new TranslatorException("Argument target is null! Translation of a source dto must be based on a existing target businessclass");
                      }
                      if (source.getId() != target.getId()) {
                          throw new TranslatorException("Can not translate a dto to a businessclass object when the id of the dto differs from the businessclass id.");
                      }
                  «ENDIF» 
                  target.activateValidation(false);                 
                  
                  «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                      «IF dataProperty.metaType == DtoEnumerationProperty -»
                          target.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.fromDto(source.get«javaClassName(dataProperty.name)»()));
                      «ELSE -»
                          target.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                      «ENDIF -»
                  «ENDFOREACH»
                  target.activateValidation(true);

                  return target;
              }
             
             /**
              * Translates a «javaClassName(base.name)» businessclass object into a «javaClassName(name)» dto object. Properties and associations in the businessclass object
              * will be mapped to the corresponding properties and associations in the dto object.
              * To prevent looping while translating biderectional or circulair associations translated objects will be added to the 'translated' register.    
              *
              * @param source The {@link «javaClassName(base.name)»} object to translate.
              *
              * @return «javaClassName(name)» The {@link «javaClassName(name)»} object translated from source.
              */
              public synchronized «javaClassName(name)» toDto(final «javaClassName(base.name)» source) {
              
                  «FOREACH associationReferences AS assRef -»    
                      «EXPAND getBaseDtoName FOR assRef.dtoType»Translator «assRef.name»Translator = «EXPAND getBaseDtoName FOR assRef.dtoType»Translator.getInstance();
                  «ENDFOREACH»  
                 
                  if (source == null ) {
                      throw new TranslatorException("Argument source is null! Translation of a businessclass object can not be based on a null businessclass.");
                  }
                  
                  if (translated.containsKey((source))) {
                      return translated.get(source);
                  }
 
                  «javaClassName(name)» result = new «javaClassName(name)»();
                 
                  result.setId(source.getId());
                  «FOREACH properties.typeSelect(DtoDataProperty) AS dataProperty -»
                      «IF dataProperty.metaType == DtoEnumerationProperty -»
                          result.set«javaClassName(dataProperty.name)»(«dataProperty.name»Translator.toDto(source.get«javaClassName(dataProperty.name)»()));
                      «ELSE -»
                          result.set«javaClassName(dataProperty.name)»(source.«getterPrefix(dataProperty)»«javaClassName(dataProperty.name)»());
                      «ENDIF -»
                  «ENDFOREACH»
                  translated.put(source, result);
                  «FOREACH associationReferences AS assRef -»
                     «IF assRef.dtoType.metaType == ListDto -» «REM»2Many«ENDREM» 		              
 		                  for («EXPAND getBaseDtoBaseName FOR assRef.dtoType -» element: source.get«assRef.name.toFirstUpper()»()) {
		                      result.addTo«assRef.name.toFirstUpper()»(«assRef.name»Translator.toDto(element));
		                  }
		             «ELSE -» «REM»2One«ENDREM»
		                 if( source.get«assRef.name.toFirstUpper()»() != null ) {
		                     result.set«assRef.name.toFirstUpper()»(«assRef.name»Translator.toDto(source.get«assRef.name.toFirstUpper()»()));
		                 }
		             «ENDIF -»
		          «ENDFOREACH»
		          translated.remove(source);

                  return result;
              }
          }
    «ENDFILE»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR ListDto -»
    «javaClassName(baseDto.name) -»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR BusinessClassDto -»
    «javaClassName(name) -»
«ENDDEFINE»

«DEFINE getBaseDtoName FOR ListDto -»
    «javaClassName(baseDto.name) -»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR Dto -»
    «REM»Nothing to generate for this superclass«ENDREM»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR BusinessClassDto -»
    «javaClassName(base.name) -»
«ENDDEFINE»

«DEFINE getBaseDtoBaseName FOR ListDto -»
    «EXPAND getBaseDtoBaseName FOR baseDto -»
«ENDDEFINE»