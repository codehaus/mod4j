/* 
   This file contains the code to create a Crossx model from a BusinesDomainDsl model.
   Needed for crosssreference purposes.
*/

import crossx;
import BusinessDomainDsl;

create ModelInfo exportModel(BusinessDomainModel busModel, String modelFile) :
    this.setDslname("BusinessDomainDsl")->
    this.setModelname(busModel.name)->
    this.setResource(modelFile)->
    this.symbols.addAll(busModel.types.typeSelect(BusinessClass).toElement())->
    this.symbols.addAll(busModel.enumerations.toElement());
    
Symbol toElement(Enumeration enum) :
    let result = new Symbol :
    result.setName(enum.name) ->
    result.setType("Enumeration")->
    result.subSymbols.addAll(enum.enumerationLiterals.toElement() )->
    result
    ;

Symbol toElement(EnumerationLiteral lit) :
    let result = new Symbol :
    result.setName(lit.name) ->
    result.setType("EnumerationLiteral")->
    result
    ;


Symbol toElement(BusinessClass cls) :
    let result = new Symbol :
    result.setName(cls.name) ->
    result.setType("BusinessClass")->
    result.subSymbols.addAll(cls.properties.toElement() )->
    (cls.superclass != null ? result.subSymbols.addAll( cls.superclass.properties.toElement()): null)->
    result.subSymbols.addAll( cls.associationsTo.toSymbol() )->
    result.subSymbols.addAll( cls.associationsFrom.select(e|e.bidirectional).fromSymbol() )->
    result
    ;

/** Create a new Symbol of type "Association" for 'ass'
 */
crossx::Symbol toSymbol(BusinessDomainDsl::Association ass) :
    let result = new Symbol :
    result.setName(ass.targetRoleName )->
    result.setType("Association")->
    result.properties.add( multiplicityProperty(ass.targetMultiplicity) )->
    result.properties.add( newProperty("BusinessClass", ass.target.name))->
    result;

crossx::Symbol fromSymbol(BusinessDomainDsl::Association ass) :
    let result = new Symbol :
    result.setName(ass.sourceRoleName )->
    result.setType("Association")->
    result.properties.add( multiplicityProperty(ass.sourceMultiplicity) )->
    result.properties.add( newProperty("BusinessClass", ass.source.name))->
    result;

LiteralSymbolProperty multiplicityProperty(BusinessDomainDsl::Multiplicity mult) :
    let result = new LiteralSymbolProperty :
	result.setName("Multiplicity")->
	result.setValue(mult.asString())->
    result
    ;
    
String asString(BusinessDomainDsl::Multiplicity mult) :
    switch( mult ) {
        case Multiplicity::One      : "1"
        case Multiplicity::ZeroOne  : "0..1"
        case Multiplicity::ZeroMany : "0..*"
        case Multiplicity::OneMany  : "1..*"
        default : "UNKNOWN"
    };

crossx::Symbol toElement(BusinessDomainDsl::Property prop) :
    let result = new Symbol :
    result.setName(prop.name) ->
    result.setType("Property") ->
    result.properties.add(prop.toLiteralProperty())->
    result.properties.add(newProperty("Nullable", (prop.nullable? "true" : "false") ))->
    result
    ;
    
crossx::Symbol toElement(BusinessDomainDsl::EnumerationProperty prop) :
    let result = new Symbol :
    result.setName(prop.name) ->
    result.setType("Property") ->
    result.properties.add(prop.toLiteralProperty())->
    result.properties.add(newProperty("Nullable", (prop.nullable? "true" : "false") ))->
    result
    ;

crossx::LiteralSymbolProperty toLiteralProperty(BusinessDomainDsl::Property prop) :
	newProperty("DataType", prop.dataType);

crossx::LiteralSymbolProperty toLiteralProperty(BusinessDomainDsl::EnumerationProperty prop) :
    newProperty("DataType", prop.type.name)  ;
    
crossx::LiteralSymbolProperty newProperty(String name, String value) :
    let result = new LiteralSymbolProperty :
    result.setName(name)->
    result.setValue(value)->
    result
    ;


    
    