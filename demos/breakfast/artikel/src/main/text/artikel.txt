Mod4j artikel

(Enterprise Java Applications)

Het ontwikkelen van web applicaties in Java Enterprise Edition is moeilijk.
Voor een deel hebben we dat aan onszelf te danken, omdat we per se een
complexe meerlaagse architectuur willen hanteren. Daar zijn goede redenen
voor - separation of concerns, onderhoudbaarheid, hergebruik van code - maar
het wordt daar niet makkelijker van. Een actie van de gebruiker moet zich door
alle lagen heen worstelen naar de database en terug. Natuurlijk zijn we in de
Java wereld gezegend met talloze frameworks en libraries, die ons veel werk
uit handen nemen. Maar die zelfde zegen dreigt in een vloek te veranderen door
het steeds groeiende aantal frameworks en libraries waaruit we moeten kiezen.
Aan de achterkant van een applicatie - de kant het dichtst bij de database -
valt het nog wel mee: Hibernate is een blijvertje gebleken, al of niet vermomd
als JPA. En ook het Spring-framework blijft een rots in de branding. Maar aan
de voorkant - de kant het dichtst bij de gebruiker - is de grote lijn helemaal
zoek. Het is alweer jaren geleden dan Struts éénook koning was, maar nu moet
je voor iedere applicatie opnieuw kiezen tussen JSF, Wicket, GWT, Spring MVC
of Webflow, of toch maar een Rich Client. Het valt niet meer bij te houden
voor een gewoon mens die 's-avonds ook nog wel eens naar een film wil kijken,
in plaats van een tutorial (als dat er is tenminste) van wéér en nieuw
framework door te werken.

Bovendien spreken we wel over Java applicaties, maar in werkelijkheid hebben
we met meer talen te maken. SQL voor database toegang, XML voor configuratie
of voor communicatie met andere applicaties, HTML voor presentatie, JSP voor
het tonen van dynamische informatie in web pagina's, speciale XML schema's
voor Spring configuratie en Hibernate mappings, en waarschijnlijk zijn we er
nog een aantal vergeten. Het consistent maken en houden van al deze source- en
configuratie files vergt het uiterste van ontwikkelaars. En wat erger is, het
is tijdrovend. En onze tijd kost veel geld, zeker vergeleken met die van een
Indiër. En ook al gaat niet alle time-to-market op aan coderen - de enterprise
architecten en requirement engineers kunnen er ook wat van! - het maakt die zeker niet korter.

(Model Driven Development)

Alle hierboven genoemde problemen schreeuwen om een oplossing. Model-driven
development - het genereren van code uit modellen - belooft zo'n oplossing,
in de vorm van van gebruiksgemak, consistentie en kwaliteit van de
architectuur, relatieve ongevoeligheid voor veranderingen in technologie,
productiviteit en de daaruit voorvloeiende kortere time-to-market. Immers, een
model heeft een hoger abstractieniveau dan code in een derde-generatie
programmeertaal als Java, en is daardoor compacter en dus sneller te maken.
Automatisch gegenereerde code heeft een constante kwaliteit, is altijd in
overeenstemming met de gekozen architectuur. Bij veranderingen in technologie
moet wel de generator aangepast of herschreven worden, maar de modellen niet.

(Traditional MDD)

Toch reageren Java architecten en -ontwikkelaars gereserveerd of zelfs
afwijzend bij het horen van deze beloften. Vooral degenen die ervaringen
achter de rug hebben met "traditionele" model-driven codegeneratoren,
gebaseerd op de Model Driven Architecture (r) (MDA(r)) van de Object
Management Group (tm) (OMG(m)). Die hebben nu nòg nachtmerries van Platform
Independent Models, Platform Specific Models, files met "guarded blocks"
waaraan handmatig code moest worden toegevoegd, en de verschillende
transformatoren en code-generatoren om de één te transformeren in de ander. In
plaats van één plek om aanpassingen te maken waren er nu vijf! Twee modellen,
één verzameling source files, de PIM-to-PSM transformator en de
code-generator. En hoe moest je daar nu de juiste uit kiezen? Voor een normaal
mens niet te doen, de meeste ontwikkelaars zijn nu eenmaal normale mensen. En
MDA was gebaseerd op modellen in UML, terwijl UML nooit bedoeld is geweest, en
ook helemaal niet geschikt is om code uit te genereren. Véél te ingewikkeld en
uitgebreid, en tegelijkertijd semantisch niet exact genoeg.

(Modern MDD)

Maar MDD heeft ook geleerd van die ervaringen en doet het nu anders. UML als
modelleertaal is verlaten en ervoor in de plaats zijn domain-specific
languages (DSL's) gekomen. Het domain-specific roept bij veel mensen het idee
op van specifiek voor het domein van de gebruiker van de applicatie. Maar
meestal is dat niet zo. Een zó domeinspecifieke taal is namelijk niet
herbruikbaar voor andere applicaties en de investering is dan moeilijk terug
te verdienen. Als domein wordt daarom vaak de architectuur van de applicatie
gekozen. De domeinspecifieke taal bevat dan ook de concepten uit die
architectuur, zoals domein model, class, associatie, service et cetera.
Concepten die dicht bij de code liggen.

(Mod4j)

Mod4j is ontwikkeld volgens deze nieuwe MDD inzichten. Het idee van DSL's is
nog verder doorgevoerd, door niet één DSL te ontwikkelen, maar verschillende
samenwerkende DSL's, specifiek voor de verschillende lagen van de
applicatiearchitectuur. Het is duidelijk wat het voordeel daarvan is: nòg
kleinere DSL's, en daarmee ook kleinere en simpelere codegeneratoren. Iedere
DSL kan op zichzelf worden aangepast of in z'n geheel vervangen. En nieuwe
DSL's kunnen worden toegevoegd op het moment dat daar behoefte aan ontstaat.
Nog een nieuwigheid is dat de modellen in Mod4j tekstueel zijn in plaats van
de UML diagrammen die in MDA gebruikt worden. Hoewel in eerste instantie
ontwikkeld door Ordina medewerkers is Mod4j een open source project. Dat is
niet zozeer een kwestie van onzelfzuchtigheid, maar van noodzaak. Een
gebruiker van Mod4j kan niet het risico lopen afhankelijk te worden van een
tool die hij niet kan aanpassen als dat nodig is. En de voordelen van het open
source model zijn noodzakelijk om de benodigde flexibiliteit te bereiken. 

(Mod4j Architecture)

Een belangrijke best-practice bij het ontwikkelen van codegeneratoren is, dat
je van tevoren een goed idee moet wàt je precies wilt genereren. Bij de
ontwikkeling van de eerste set codegeneratoren voor Mod4j hebben we daarom van
tevoren een architectuur opgesteld en een voorbeeldapplicatie ontwikkeld
volgens die architectuur. Die architectuur is min of meer de standaard
architectuur voor Java web applicaties: (plaatje) een presentatie- een
service- een business- en een datalaag, en een domeinmodel dat geen echte laag
is, omdat het door drie andere lagen gebruikt wordt. Het plaatje laat zien
welke artifacts uit de verschillende modellen gegenereerd worden.

(Coding Only)
(DSL and Coding Combined)

Er is een belangrijke reden om zoveel aandacht aan de architectuur van de
gegenereerde applicatie te besteden: die applicatie kan namelijk geen
black-box zijn. We hebben niet de illusie dat we die in z'n geheel kunnen
genereren. De standaard functionaliteit voor het vastleggen, opvragen en
wijzigen van gegevens kan wel gegenereerd worden, maar iedere niet-triviale
applicatie heeft meer dan dat nodig. Als die gemodelleerd zou worden zou de
DSL die daarvoor nodig is zoveel uitgebreider moeten worden, dat die het
karakter van een algemene programmeertaal zou krijgen. Dan is het al geen DSL
meer. Daarom biedt Mod4j het beste van twee werelden: enerzijds modellen en
daaruit gegenereerde code voor de standaard functionaliteit, en de volledige
kracht van Java voor de rest.

(Mod4j Principles)

Bij de ontwikkeling van Mod4j zijn een aantal principes gehanteerd. 

1. De DSL's zijn niet bedoeld voor eindgebruikers, maar voor ontwikkelaars.
   Ondanks de zo ongeveer ieder halfjaar door iemand herhaalde voorspelling
   dat er programmeerhulpmiddelen zullen komen waarmee eindgebruikers zèlf
   software kunnen ontwikkelen, geloven wij dat dat niet gaat gebeuren.
   Programmeren blijft een vak.

2. Modelleren moet gemakkelijker zijn dan coderen. Zoals eerder gezegd hebben
   sommigen van ons nog nachtmerries van MDA. Een "gewone" programmeur moet
   het kunnen.

3. Modellen worden gebruikt in combinatie met handgeschreven code.
   Model-driven codegeneratie is geen alles-of-niets kwestie. Beiden worden
   gebruikt waarvoor ze het beste geschikt zijn.

4. Meerdere kleine DSL's kunnen onafhankelijk van elkaar gebruikt worden. Als
   een DSL's niet of nog niet de gewenste code genereert moet het mogelijk
   zijn die DSL niet te gebruiken en die code handmatig te ontwikkelen. Op dit
   moment bijvoorbeeld is de presentatie DSL nog niet af en moet de
   presentatielaag dus met de hand geschreven worden.

5. Gegenereerde code wordt nooit handmatig aangepast. DSL's worden gedurende
   de gehele levenscyclus van de applicatie gebruikt. Hoewel het soms nuttig
   kan zijn om applicatie éénmaal te genereren en daarna handmatig verder te
   ontwikkelen, is het voordeel vele malen groter als onderhoud ook op het
   niveau van de modellen wordt gedaan, en daaruit steeds opnieuw code te
   genereren. Er zijn wel precies gedefiniëerde extension points waar de
   gegenereerde code met handmatige aanpassingen uitgebreid of overruled kan
   worden. Maar de handmatige aanpassingen blijven altijd gescheiden van de
   gegenereerde code.

6. De genereerde code moet leesbaar zijn. Daarvoor zijn verschillende redenen.
   De belangrijkste daarvan is dat de code handmatig uitbreidbaar moet zijn.
   Dat kan alleen betrouwbaar gebeuren als die code begrijpelijk is. Een
   andere reden is dat er nog geen debuggers bestaan op model-niveau. Dat
   betekent dat alleen de gegenereerde code gedebugd kan worden, en dat heeft
   weinig zin als die onbegrijpelijk is. Een derde reden is, dat altijd de
   mogelijkheid opengehouden moet worden dat verder onderhoud met de DSL's
   niet mogelijk of niet gewenst is. De applicatie moet dan nog altijd
   handmatig onderhoudbaar zijn, zodat er een uitweg is.

7. De resulterende applicatie is een "normale" Java applicatie. De toepassing
   van Mod4j moet geen gevolgen hebben voor de deployment en het beheer van de
   applicatie. Er is daarvoor geen nieuwe opleiding of nieuwe kennis vereist.
   Bestaande kennis en ervaring blijft voldoende.

8. De omgeving moet flexibel zijn om te kunnen meegroeien met de voortdurend
   veranderende omgeving. DSL's zullen aangepast moeten worden en er zullen
   nieuwe DSL's ontwikkeld moeten worden. Voor de bestaande DSL's zal nieuwe
   code gegenereerd moeten worden, zodat de codegeneratoren aangepast moeten
   worden of geheel herschreven worden.

(Code Generation Flexibility)

De door Mod4j gegenereerde code bevat uitbreidingspunten volgens een vast
patroon. Dat patroon is al, onder de naam "Generation Gap", in 1996
gedocumenteerd door John Vlissides, één van de vier auteurs (de beroemde "Gang
of Four") van het baanbrekende boek op het gebied van patterns: "Design
Patterns: Elements of Reusable Object-Oriented Software". (plaatje) Iedere
gegenereerde klasse bestaat uit twee klassen: één abstracte volledig
gegenereerde superklasse, en één concrete subklasse die alleen de eerste keer
gegenereerd wordt en door de ontwikkelaar handmatig uitgebreid kan worden. De
gegenereerde abstracte klasse mag nooit aangepast worden, omdat die altijd
opnieuw gegenereerd kan worden waarbij aanpassingen verloren zouden gaan. Dit
pattern heeft de voorkeur boven het vroeger veelgebruikte "guarded block"
pattern. Dat laatste heeft een aantal nadelen, zoals een onduidelijk interface
tussen gegenereerde en handmatige code, en problemen met versiebeheer. Het
principe van overerving daarentegen is bekend bij OO ontwikkelaars, en
profiteert van ondersteuning van de compiler, die dit principe "begrijpt".

In Mod4j passen we ook een variant van het Generation Gap pattern toe
(plaatje), waarbij de klasse gesplitst is in een apart interface en een
implementatieklasse.  Hierbij is het interface gesplitst in een gegenereerde
superinterface en een handmatige subinterface, en een abstracte gegenereerde
superklasse die de genereerde interfact implementeert, en een handmatige
concrete subklasse die overerft van de gegenereerde abstracte klasse en de
handgeschreven interface implementeert, en daarmee ook de abstracte
gegenereerde superinterface.

Voor Spring configuratie gebruiken we een constructie die op het Generation
Gap pattern geïnspireerd is. Dit is mogelijk omdat Spring het mogelijk maakt
dat een application context een parent context heeft, waarvan de beans wel
zichtbaar zijn in de child context, maar niet andersom. De parent context is
volledig gegenereerd en de inhoud kan in de child context uitgebreid of
overridden worden. De beide contexten worden aanelkaar geknoopt door een
SingletonBeanFactoryLocator (Spring classname), geconfigureerd aparte XML
configuratie file.

(Mod4j DSL's_)

De kern van een applicatie is een domein model, een model van de object typen
waar de applicatie over gaat. Het domein model wordt gemodelleerd in de
Business Domain DSL. Het UML model in figuur x (plaatje) is ontleend aan de
applicatie die in "MDA..." (boek ref.) als voorbeeld werd gebruikt: "Rosa's
Breakfast Service". In figuur x (plaatje) wordt hetzelfde model weergegeven in
de Business Domain DSL van Mod4j.

(Business Domain DSL)
(Data Contract DSL)
(Service DSL)
(A DSL Model is a source file)
(Mod4j features)
(Current Status)
(Mod4j FAQ)
