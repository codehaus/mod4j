<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4/EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"[
<!ENTITY mod4j "<ulink url='http://www.mod4j.org/'>Mod4j</ulink>">
]>
<article lang="nl">
  <title>Model-driven development in de praktijk</title>
  <articleinfo>
    <author>
      <firstname>Eric</firstname>
      <othername>Jan</othername>
      <surname>Malotaux</surname>
    </author>
    <author>
      <firstname>Jos</firstname>
      <surname>Warmer</surname>
    </author>
  </articleinfo>
  <section>
    <title>Introductie</title>
    <para>Toen Jos Warmer twee jaar geleden een presentatie gaf over zijn model-driven
      ontwikkelstraat voor Microsoft .NET voor een aantal Java architecten, en aan het einde daarvan
      aankondigde iets dergelijks te willen ontwikkelen voor Java, was de reactie sceptisch. De
      meesten hadden ervaringen achter de rug met model-driven programmageneratoren gebaseerd op de
        <trademark class="registered">Model Driven Architecture</trademark> (<trademark
        class="registered">MDA</trademark>) van de <trademark>Object Management Group</trademark>
        (<trademark>OMG</trademark>), en wilden dat liever niet nog eens meemaken. Degenen zonder
      MDA verleden hadden ook slechte ervaringen met code-generatie, of andere high-level talen
      zoals 4GL's. Die werken snel als je precies het soort applicatie nodig hebt waarvoor de tool
      gemaakt is. Maar alles wat je daarbuiten wilt kost meteen onevenredig veel meer tijd. De
      heersende mening was dat Java met een uitgekiende combinatie van frameworks de way to go was.
      Niet onverwacht natuurlijk, voor Java architecten. En er zijn goede argumenten te geven voor
      de stelling dat open source frameworks en libraries de productiviteit van Java op een
      vergelijkbaar niveau hebben gebracht als die van 4GL's, maar dan met behoud van de
      flexibiliteit van een 3GL.</para>
    <para>Toch zijn we uiteindelijk met de ontwikkeling van Mod4j begonnen, een model-driven
      ontwikkelomgeving voor Java. Dit artikel beschrijft waarom en hoe we dat gedaan hebben. Sectie
      2 beschrijft welke overwegingen ertoe geleid hebben toch een MDD ontwikkelomgeving te willen
      maken. Sectie 3 noemt de doelstellingen die we hebben geprobeerd te bereiken. In secties 4, 5,
      6 en 7 lopen we langs een aantal valkuilen uit het verleden en beschrijven hoe we die met
      Mod4j hebben geprobeerd te omzeilen. In sectie 8 geven we een voorbeeld van een deel van een
      Mod4j applicatie. In sectie 9 tenslotte noemen we een aantal eigenschappen die Mod4j nu niet
      heeft, maar die we wellicht in de toekomst willen gaan toevoegen.</para>
  </section>
  <section>
    <title>Waarom Mod4j?</title>
    <para>Zoals in de inleiding gesteld zijn er in het verleden al vaak model-driven codegeneratoren
      geweest, en zijn die zelden een doorslaand succes geweest. Een aantal ontwikkelingen hebben
      ons desondanks over de streep getrokken om met Mod4j een nieuwe poging te wagen:<itemizedlist>
        <listitem>
          <para>Ten eerste, de steeds toenemende complexiteit van de Java wereld. De beschikbaarheid
            van open source libraries en frameworks is goed, maar er zijn er inmiddels zóveel, dat
            ontwikkelaars erin dreigen te verdrinken.</para>
        </listitem>
        <listitem>
          <para> Ten tweede, model-driven development op basis van domain-specific languages (DSL's)
            is iets anders dan met UML. UML is te generiek en daarom te uitgebreid en moeilijk te
            leren, en tegelijk semantisch niet precies genoeg als basis voor code-generatie. DSL's
            zijn eenvoudiger, want ontworpen voor een specifiek probleemgebied en daarom makkelijker
            te leren. En als je ze zelf ontwerpt kun je zo ook precies genoeg maken om werkende code
            uit te kunnen genereren.</para>
        </listitem>
        <listitem>
          <para>Ten derde, er zijn inmiddels goede open source tools, zoals oAW, waarmee het maken
            van DSL's en de benodigde editors, parsers en code-generatoren binnen het bereik van
            gewone ontwikkelaars is gekomen.</para>
        </listitem>
        <listitem>
          <para>Ten vierde, met Xtext, onderdeel van oAW, kunnen tekstuele syntaxen voor DSL gemaakt
            worden. Grafische syntaxen zijn misschien aantrekkelijk voor business mensen, maar
            ondanks de voorspellingen die al tientallen jaren gedaan worden zullen business mensen
            echt nooit gaan programmeren. En programmeurs zijn gewoon veel productiever met het
            intypen van programma's in plaats van diagrammen te tekenen. Daarbij ben je teveel tijd
            kwijt met de layout, en met het rechtsklikken op piefjes en het invullen property
            sheets.</para>
        </listitem>
      </itemizedlist></para>
  </section>
  <section>
    <title>Doelen</title>
    <para>
      <itemizedlist>
        <listitem>
          <para>Leren DSL&apos;s maken.</para>
        </listitem>
        <listitem>
          <para>Sneller web applicaties bouwen.</para>
        </listitem>
      </itemizedlist>
    </para>
  </section>
  <section>
    <title>Gegenereerde en handgeschreven code</title>
    <para>Volledige code generatie is voorlopig nog een utopie. Er blijven altijd details over waar
      de codegenerator niet in voorziet. Dat betekent dat handgeschreven Java code moet kunnen
      worden toegevoegd aan de gegenereerde code. Tegelijk moet die laatste steeds opnieuw
      gegenereerd kunnen worden, zonder de handgeschreven code te overschrijven.
      &Eacute;&eacute;nmalige codegeneratie kan ook nuttig zijn, maar model-driven development
      levert zijn grootste voordeel op als de applicatie voortdurend op model-niveau onderhouden kan
      blijven worden.</para>
    <para>Mod4j gebruikt voor het combineren van gegenereerde en handgeschreven code het
        <emphasis>Generation Gap</emphasis> pattern. Een goede beschrijving van dit pattern is te
      vinden op <olink>http://www.research.ibm.com/designpatterns/pubs/gg.html</olink>. Voor iedere
      class in een DSL worden twee Java classes gegenereerd in twee aparte files: een abstracte
      superclass die steeds opnieuw gegenereerd kan worden, en een concrete subclass die éénmalig
      vrijwel leeg gegenereerd wordt en daarna handmatig uitgebreid kan worden. Deze laatste file
      wordt nooit overschreven door code-generatie. Referenties vanuit andere classes gaan altijd
      naar de "handmatige" subclass, zodat de uitbreidingen altijd van kracht zijn.</para>
    <para>Wij gaven de voorkeur aan het <emphasis>Generation Gap</emphasis> pattern boven het
        <emphasis>guarded block</emphasis> pattern. Bij het <emphasis>guarded block</emphasis>
      pattern worden speciaal gemarkeerde blokken aan de gegenereerde code toegevoegd, waar
      handgeschreven code in kan worden gezet, die niet wordt overschreven door de codegenerator.
      Aan het <emphasis>guarded blocks</emphasis> mechanisme kleven verschillende problemen. Het
      vermengen van gegenereerde en handgeschreven code is foutgevoelig. De handgeschreven
      toevoegingen kunnen subtiele fouten introduceren die pas in de gegenereerde code tot uiting
      komen, waardoor ze moeilijk te vinden zijn. De interactie tussen gegenereerde en
      handgeschreven code is ad hoc. Er is weinig support voor van de compiler. Het generation gap
      pattern daarentegen sluit aan bij het voor OO-ontwikkelaars bekende principe van overerving.
      Wel is het zo, dat wanneer de abstracte superclass opnieuw gegenereerd wordt, de concrete
      subclass nu, zonder dat die gewijzigd is, fouten kan bevatten die er eerst niet waren. Maar
      bij het herstel hiervan kan de compiler wel goede hulp bieden.</para>
    <para>Een ander probleem met het <emphasis>guarded block</emphasis> pattern is dat het
      versiebeheer van files met een mix van gegenereerde en handmatige code lastig is. Omdat de
      gegenereerde files handmatige toevoegingen kunnen bevatten moeten ze onder versiebeheer worden
      gebracht. Daarmee is de gegenereerde code dat ook, wat leidt tot de ongewenste situatie dat
      afgeleide produkten zowel als de produkten waaruit ze worden afgeleid - de model files - onder
      versiebeheer staan. Dat opent de mogelijkheid dat deze twee elkaar kunnen tegenspreken, met
      alle gevolgen van dien. Het <emphasis>Generation Gap</emphasis> pattern heeft dat probleem
      niet: alleen de handmatige aangepaste files hoeven onder versiebeheer gebracht te worden; de
      puur gegenereerde files niet.</para>
  </section>
  <section>
    <title>Software engineering <emphasis role="italic">best-practices</emphasis></title>
    <para> De Java community is altijd sterk geweest in bewezen software engineering best-practices
      zoals unit testing, <emphasis>automated builds</emphasis>, <emphasis>continuous
        integration</emphasis> en versiebeheer. Er is geen reden om die overboord te gooien zodra we
      model-driven development gaan doen, maar veel MDD tools hebben ze moeilijk of onmogelijk
      gemaakt. Toch is er wat voor te zeggen dat deze best-practices uiteindelijk minstens zo
      belangrijk zijn voor een succesvol project als programmeertaal of architectuur.</para>
    <para>Voor een Mod4j-project worden een aantal maven POM's gegenereerd, zodat het meteen vanaf
      het begin automatisch door maven gebouwd kan worden. Daarmee is meteen de voornaamste
      voorwaarde voor <emphasis>continuous integration</emphasis> vervuld. Het feit dat de DSL's van
      Mod4j tekstueel zijn in plaats van grafisch, heeft onder andere het voordeel dat bewezen en
      vertrouwde versiebeheer tools ongewijzigd gebruikt kunnen worden. Tekstfiles kunnen eenvoudig
      vergeleken en <emphasis>gemerged</emphasis> worden. Voor grafische DSL's zijn daarvoor
      speciale tools nodig, en die zijn er vaak niet, of werken niet probleemloos. De model files
      vormen de natuurlijke eenheden van versiebeheer.</para>
  </section>
  <section>
    <title>Standaarden</title>
    <para>De kwaliteit van de code die door model-driven generatoren gemaakt wordt is altijd een
      punt van zorg geweest. Bij de ontwikkeling van Mod4j hebben gemerkt dat het niet makkelijk is
      om evenveel aandacht te besteden aan de codegenerator enerzijds, en de gegenereerde code
      anderzijds. Het is makkelijk om een generator te schrijven voor de applicaties waar we een
      paar jaar geleden behoefte aan hadden. We hebben een aantal maatregelen genomen om de
      kwaliteit zo hoog mogelijk te krijgen. Ten eerste is de applicatie die gegenereerd wordt
      gebaseerd op een referentiearchitectuur. En op een referentieapplicatie die zorgvuldig volgens
      de referentiearchitectuur gebouwd is. Dat betekent dat alle architectuurprincipes zoals
      &lt;i>separation-of-concerns&lt;/i>, high-cohesion, low-coupling et cetera, in ere gehouden
      worden. Ten tweede is de gegenereerde code zo leesbaar en begrijpelijk mogelijk. De
      gegenereerde applicatie is niet te onderscheiden van een met de hand gebouwde, behalve dat die
      netter is dat met de hand ooit bereikbaar is. Een belangrijk neveneffect daarvan is dat de
      applicatie nooit afhankelijk wordt van de generator. Natuurlijk is het onderhoud zonder
      generator arbeidsintensiever, maar niet arbeidsintensiever dan wanneer de applicatie van begin
      af aan zonder generator gebouwd was. En het is belangrijk dat er een uitweg is als de
      generator niet meer voldoet. Ten derde is de gegenereerde applicatie gebaseerd op de JEE
      standaard, en kan op alle JEE-compliant applicatie servers gedeployed worden. Dezelfde
      frameworks, zoals Spring, Hibernate, Wicket of JSF en Log4j worden gebruikt als bij
      handgecodeerde applicaties. Dat maakt niet alleen de codegenerator eenvoudiger, ook de
      resulterende applicatie wordt herkenbaarder voor de ontwikkelaars en beter
      onderhoudbaar.</para>
  </section>
  <section>
    <title>Flexibiliteit</title>
    <para>Het soort applicaties dat de markt van ons vraag verandert voortdurend. Anders was ons vak
      ook niet zo moeilijk geweest. Dat betekent dat Mod4j, om bruikbaar te blijven, ook voortdurend
      mee moet kunnen veranderen. Daarom hebben we niet geprobeerd om alleen maar een model-driven
      ontwikkelomgeving te bouwen. De kosten daarvan zijn voor één bedrijf moeilijk op te brengen en
      nog moeilijker terug te verdienen. Daarom is van Mod4j een open source project gemaakt.
      Gebruikers hebben zo de vrijheid om Mod4j aan hun eigen behoeften aan te passen. Er zijn
      verschillende manieren waarop Mod4j aangepast kan worden, in toenemende mate van
      ingrijpendheid. Het "Generation Gap" pattern is hierboven al beschreven. Daarmee kan de
      werking van de gegenereerde code aangepast worden. Dat is het minst ingrijpend, omdat er
      daarvoor geen enkele aanpassing aan Mod4j nodig is. Als dat niet voldoet kunnen de code
      generation templates aangepast worden. Dat is al ingrijpender, omdat daarvoor één of meer
      Mod4j Eclipse plugins vervangen moet worden door een aangepaste versie. Op dit moment kent
      Mod4j geen plugin of cartridge-mechanisme voor het eenvoudig vervangen van generatoren. Er is
      kennis nodig van de metamodellen waarop de DSL's gebaseerd zijn. De aanpassingen kunnen in
      allerlei gradaties plaatsvinden, van alleen kleine wijzigingen, tot het compleet vervangen van
      alle templates. Daarbij moet er rekening mee gehouden worden, dat de voor de verschillende
      DSL's gegenereerde code op elkaar moet aansluiten. Als dat niet voldoet kunnen de DSL's zelf
      aangepast worden. Op zichzelf is daar weinig winst mee te behalen, omdat er daarbij ook al
      gauw wijzigingen vereist zijn op de metamodellen van de DSL's. Het metamodel is de abstracte
      syntax van een DSL, waar de DSL één van de mogelijke concrete syntaxen vormt. De meest
      ingrijpende aanpassing is het toevoegen van volledig nieuwe DSL's. De verschillende DSL's in
      Mod4j zijn losjes gekoppeld door middel van CrossX. Met CrossX kunnen selectief delen van een
      DSL gepubliceerd worden waaraan door andere DSL's gerefereerd moet kunnen worden. Dat maakt
      het mogelijk dat modellen modulair opgebouwd worden. Modellen kunnen gepartitioneerd worden
      over verschillende DSL's, maar ook binnen één DSL. Code hoeft alleen per DSL gegenereerd te
      worden. Dat hoeft dus nooit lang te duren, en daarom gebeurt dat ook automatisch iedere keer
      als een model-file opgelagen wordt. Daarmee is Mod4j zeer schaalbaar.</para>
  </section>
  <section>
    <title>Voorbeeld</title>
    <para>Dit artikel zou niet volledig zijn zonder voorbeelden. Ons voorbeeld is gebaseerd op
      dezelfde applicatie die dienst deed als voorbeeld in het boek "MDA Explained. The Model Driven
      Architecture(r): Practice and Promise" door Anneke Kleppe, Jos Warmer en Wim Bast. Het gaat om
      een web applicatie voor "Rosa's Breakfast Service". Daar kun je een ontbijt bestellen dat door
      Rosa's Breakfast Service bereid worden en op het gevraagde tijdstip op het gewenste adres
      bezorgd wordt. Verdere details laten we hier achterwege. Figuur 1 toont een UML class-diagram
      van de belangrijkste classes in de applicatie. Voorbeeld 1 toont het tekstuele model in de
      Business Domain DSL van Mod4j. <figure>
        <title>UML Model of Rosa&apos;s Breakfast Service</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/breakfast.jpg" format="JPG"/>
          </imageobject>
        </mediaobject>
      </figure> Het modelleren van een Mod4j applicatie begint bij het modelleren van het domein.
      Voorbeeld 1 toont het complete domein model van Rosa&apos;s Breakfast Service in de business
      model DSL van Mod4j. Het domein model heeft een naam, <classname>breakfastDM</classname>, die
      later gebruikt zal worden om dit model te importeren in andere modellen. <example>
        <title id="breakfast.busmod">breakfast.busmod</title>
        <programlisting linenumbering="numbered" startinglinenumber="1" continuation="restarts" lang="busmod">domain breakfastDM;

class StandardBreakfast [
    string name;
    decimal price;
    ServingStyle style;
    rules [
        unique name [ name ]
    ]
]
association StandardBreakfast standard one -> many Part parts;
association Part part many -> one Comestible comestible;

enumeration ServingStyle [
    SIMPLE = 1;
    GRAND = 2;
    DELUXE = 3;
]

class Comestible [
    string name;
    integer minimalQuantity;
    decimal price;
    string transportForm nullable;
]

class Part [
    integer quantity;
    rules [
        	PartCheckMinimumQuantity;
    ]
]

class Address [
    string street;
    string number;
    string city nullable;
    string postalCode nullable;
    string telephone nullable;
]

class Customer [
    integer accountNumber;
]
association Customer customer many -> one Address address;
association Customer customer one -> many BreakfastOrder orders;

class BreakfastOrder [
    decimal discount;
    datetime orderDate;
]
association BreakfastOrder order many -> one Address deliveryAddress;
association BreakfastOrder order one -> many Breakfast breakfasts;

class Breakfast [
    integer number;
]
association Breakfast breakfast many -> one StandardBreakfast standard;
association Breakfast breakfast one -> many Change changes;

class Change [
    integer quantity;
]
association Change change many -> one Comestible comestible;</programlisting>
      </example>Klassen in het domein model kennen alleen attributen en geen operaties. Daardoor
      kunnen we vermijden dat de DSL uitgebreid zou moeten worden tot een min of meer complete
      algemene programmeertaal om het gedrag van operaties te kunnen specificeren. Uit de klassen
      worden Java classes gegenereerd, waaraan de benodigde operaties gewoon kunnen worden
      toegevoegd als methods.</para>
    <para>Uit dit model worden drie maven POM&apos;s, vierentwintig Java classes, drie Spring
      configuratie files en drie Hibernate mapping files gegenereerd. </para>
  </section>
  <section>
    <title>Toekomst</title>
    <para>Mod4j is nog verre van een compleet product. Ontbrekende features:<orderedlist>
        <listitem>
          <para>Ondersteuning voor database refactoring. Op dit moment wordt het schema voor de
            database geheel gegenereerd uit de business domain DSL, en automatisch gecre&euml;erd
            wanneer de gegenereerde applicatie voor het eerst gestart wordt. Mod4j zou in veel meer
            situaties inzetbaar zijn als het bestaande schema&apos;s zou ondersteunen, of door DDL
            te genereren in files die op de &eacute;&eacute;n andere manier aangevuld kan worden met
            handgeschreven aanpassingen.</para>
        </listitem>
        <listitem>
          <para>Nu is er een aparte DSL voor data contracten, waarmee de objecten beschreven worden
            die een applicatie naar buiten toe toont. Die zouden ook met de business model DSL
            beschreven kunnen worden, en de transformaties daartussen met een aparte transformatie
            DSL. Dit is een voorwaarde om Mod4j te kunnen inzetten in een SOA omgeving, waar meestal
            sprake is van een <emphasis>canonical datamodel</emphasis>, dat vooraf gegeven is,
            bijvoorbeeldin XML Schema files, en buiten de controle valt van de nieuw te bouwen
            applicatie.</para>
        </listitem>
        <listitem>
          <para>Een aparte DSL voor business rules.</para>
        </listitem>
      </orderedlist></para>
  </section>
  <bibliography>
    <title>Bibliografie</title>
    <biblioentry id="kleppe03">
      <abbrev>Kleppe03</abbrev>
      <title id="kleppe03_title">MDA Explained</title><subtitle>The Model Driven Architecture:
        Practice and Promise</subtitle><authorgroup>
        <author>
          <firstname>Anneke</firstname>
          <surname>Kleppe</surname>
        </author>
        <author>
          <firstname>Jos</firstname>
          <surname>Warmer</surname>
        </author>
        <author>
          <firstname>Wim</firstname>
          <surname>Bast</surname>
        </author>
      </authorgroup><publisher>
        <publishername>Addison-Wesley</publishername>
      </publisher>
      <pubdate>2003</pubdate>
    </biblioentry>
  </bibliography>
</article>
